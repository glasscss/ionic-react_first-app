{"ast":null,"code":"import { WebPlugin } from '@capacitor/core';\nimport { hexStringToDataView, mapToObject, webUUIDToString } from './conversion';\nimport { runWithTimeout } from './timeout';\nexport class BluetoothLeWeb extends WebPlugin {\n  constructor() {\n    super(...arguments);\n    this.deviceMap = new Map();\n    this.discoveredDevices = new Map();\n    this.scan = null;\n    this.DEFAULT_CONNECTION_TIMEOUT = 10000;\n    this.onAdvertisementReceivedCallback = this.onAdvertisementReceived.bind(this);\n    this.onDisconnectedCallback = this.onDisconnected.bind(this);\n    this.onCharacteristicValueChangedCallback = this.onCharacteristicValueChanged.bind(this);\n  }\n\n  async initialize() {\n    if (typeof navigator === 'undefined' || !navigator.bluetooth) {\n      throw this.unavailable('Web Bluetooth API not available in this browser.');\n    }\n\n    const isAvailable = await navigator.bluetooth.getAvailability();\n\n    if (!isAvailable) {\n      throw this.unavailable('No Bluetooth radio available.');\n    }\n  }\n\n  async isEnabled() {\n    // not available on web\n    return {\n      value: true\n    };\n  }\n\n  async enable() {\n    throw this.unavailable('enable is not available on web.');\n  }\n\n  async disable() {\n    throw this.unavailable('disable is not available on web.');\n  }\n\n  async startEnabledNotifications() {// not available on web\n  }\n\n  async stopEnabledNotifications() {// not available on web\n  }\n\n  async isLocationEnabled() {\n    throw this.unavailable('isLocationEnabled is not available on web.');\n  }\n\n  async openLocationSettings() {\n    throw this.unavailable('openLocationSettings is not available on web.');\n  }\n\n  async openBluetoothSettings() {\n    throw this.unavailable('openBluetoothSettings is not available on web.');\n  }\n\n  async openAppSettings() {\n    throw this.unavailable('openAppSettings is not available on web.');\n  }\n\n  async setDisplayStrings() {// not available on web\n  }\n\n  async requestDevice(options) {\n    const filters = this.getFilters(options);\n    const device = await navigator.bluetooth.requestDevice({\n      filters: filters.length ? filters : undefined,\n      optionalServices: options === null || options === void 0 ? void 0 : options.optionalServices,\n      acceptAllDevices: filters.length === 0\n    });\n    this.deviceMap.set(device.id, device);\n    const bleDevice = this.getBleDevice(device);\n    return bleDevice;\n  }\n\n  async requestLEScan(options) {\n    this.requestBleDeviceOptions = options;\n    const filters = this.getFilters(options);\n    await this.stopLEScan();\n    this.discoveredDevices = new Map();\n    navigator.bluetooth.removeEventListener('advertisementreceived', this.onAdvertisementReceivedCallback);\n    navigator.bluetooth.addEventListener('advertisementreceived', this.onAdvertisementReceivedCallback);\n    this.scan = await navigator.bluetooth.requestLEScan({\n      filters: filters.length ? filters : undefined,\n      acceptAllAdvertisements: filters.length === 0,\n      keepRepeatedDevices: options === null || options === void 0 ? void 0 : options.allowDuplicates\n    });\n  }\n\n  onAdvertisementReceived(event) {\n    var _a, _b;\n\n    const deviceId = event.device.id;\n    this.deviceMap.set(deviceId, event.device);\n    const isNew = !this.discoveredDevices.has(deviceId);\n\n    if (isNew || ((_a = this.requestBleDeviceOptions) === null || _a === void 0 ? void 0 : _a.allowDuplicates)) {\n      this.discoveredDevices.set(deviceId, true);\n      const device = this.getBleDevice(event.device);\n      const result = {\n        device,\n        localName: device.name,\n        rssi: event.rssi,\n        txPower: event.txPower,\n        manufacturerData: mapToObject(event.manufacturerData),\n        serviceData: mapToObject(event.serviceData),\n        uuids: (_b = event.uuids) === null || _b === void 0 ? void 0 : _b.map(webUUIDToString)\n      };\n      this.notifyListeners('onScanResult', result);\n    }\n  }\n\n  async stopLEScan() {\n    var _a;\n\n    if ((_a = this.scan) === null || _a === void 0 ? void 0 : _a.active) {\n      this.scan.stop();\n    }\n\n    this.scan = null;\n  }\n\n  async getDevices(_options) {\n    const devices = await navigator.bluetooth.getDevices();\n    const bleDevices = devices.map(device => {\n      this.deviceMap.set(device.id, device);\n      const bleDevice = this.getBleDevice(device);\n      return bleDevice;\n    });\n    return {\n      devices: bleDevices\n    };\n  }\n\n  async getConnectedDevices(_options) {\n    const devices = await navigator.bluetooth.getDevices();\n    const bleDevices = devices.filter(device => {\n      var _a;\n\n      return (_a = device.gatt) === null || _a === void 0 ? void 0 : _a.connected;\n    }).map(device => {\n      this.deviceMap.set(device.id, device);\n      const bleDevice = this.getBleDevice(device);\n      return bleDevice;\n    });\n    return {\n      devices: bleDevices\n    };\n  }\n\n  async connect(options) {\n    var _a, _b;\n\n    const device = this.getDeviceFromMap(options.deviceId);\n    device.removeEventListener('gattserverdisconnected', this.onDisconnectedCallback);\n    device.addEventListener('gattserverdisconnected', this.onDisconnectedCallback);\n    const timeoutError = Symbol();\n\n    if (device.gatt === undefined) {\n      throw new Error('No gatt server available.');\n    }\n\n    try {\n      const timeout = (_a = options.timeout) !== null && _a !== void 0 ? _a : this.DEFAULT_CONNECTION_TIMEOUT;\n      await runWithTimeout(device.gatt.connect(), timeout, timeoutError);\n    } catch (error) {\n      // cancel pending connect call, does not work yet in chromium because of a bug:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=684073\n      await ((_b = device.gatt) === null || _b === void 0 ? void 0 : _b.disconnect());\n\n      if (error === timeoutError) {\n        throw new Error('Connection timeout');\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  onDisconnected(event) {\n    const deviceId = event.target.id;\n    const key = `disconnected|${deviceId}`;\n    this.notifyListeners(key, null);\n  }\n\n  async createBond(_options) {\n    throw this.unavailable('createBond is not available on web.');\n  }\n\n  async isBonded(_options) {\n    throw this.unavailable('isBonded is not available on web.');\n  }\n\n  async disconnect(options) {\n    var _a;\n\n    (_a = this.getDeviceFromMap(options.deviceId).gatt) === null || _a === void 0 ? void 0 : _a.disconnect();\n  }\n\n  async getServices(options) {\n    var _a, _b;\n\n    const services = (_b = await ((_a = this.getDeviceFromMap(options.deviceId).gatt) === null || _a === void 0 ? void 0 : _a.getPrimaryServices())) !== null && _b !== void 0 ? _b : [];\n    const bleServices = [];\n\n    for (const service of services) {\n      const characteristics = await service.getCharacteristics();\n      const bleCharacteristics = [];\n\n      for (const characteristic of characteristics) {\n        bleCharacteristics.push({\n          uuid: characteristic.uuid,\n          properties: this.getProperties(characteristic),\n          descriptors: await this.getDescriptors(characteristic)\n        });\n      }\n\n      bleServices.push({\n        uuid: service.uuid,\n        characteristics: bleCharacteristics\n      });\n    }\n\n    return {\n      services: bleServices\n    };\n  }\n\n  async getDescriptors(characteristic) {\n    try {\n      const descriptors = await characteristic.getDescriptors();\n      return descriptors.map(descriptor => ({\n        uuid: descriptor.uuid\n      }));\n    } catch (_a) {\n      return [];\n    }\n  }\n\n  getProperties(characteristic) {\n    return {\n      broadcast: characteristic.properties.broadcast,\n      read: characteristic.properties.read,\n      writeWithoutResponse: characteristic.properties.writeWithoutResponse,\n      write: characteristic.properties.write,\n      notify: characteristic.properties.notify,\n      indicate: characteristic.properties.indicate,\n      authenticatedSignedWrites: characteristic.properties.authenticatedSignedWrites,\n      reliableWrite: characteristic.properties.reliableWrite,\n      writableAuxiliaries: characteristic.properties.writableAuxiliaries\n    };\n  }\n\n  async getCharacteristic(options) {\n    var _a;\n\n    const service = await ((_a = this.getDeviceFromMap(options.deviceId).gatt) === null || _a === void 0 ? void 0 : _a.getPrimaryService(options === null || options === void 0 ? void 0 : options.service));\n    return service === null || service === void 0 ? void 0 : service.getCharacteristic(options === null || options === void 0 ? void 0 : options.characteristic);\n  }\n\n  async getDescriptor(options) {\n    const characteristic = await this.getCharacteristic(options);\n    return characteristic === null || characteristic === void 0 ? void 0 : characteristic.getDescriptor(options === null || options === void 0 ? void 0 : options.descriptor);\n  }\n\n  async readRssi(_options) {\n    throw this.unavailable('readRssi is not available on web.');\n  }\n\n  async read(options) {\n    const characteristic = await this.getCharacteristic(options);\n    const value = await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.readValue());\n    return {\n      value\n    };\n  }\n\n  async write(options) {\n    const characteristic = await this.getCharacteristic(options);\n    let dataView;\n\n    if (typeof options.value === 'string') {\n      dataView = hexStringToDataView(options.value);\n    } else {\n      dataView = options.value;\n    }\n\n    await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.writeValueWithResponse(dataView));\n  }\n\n  async writeWithoutResponse(options) {\n    const characteristic = await this.getCharacteristic(options);\n    let dataView;\n\n    if (typeof options.value === 'string') {\n      dataView = hexStringToDataView(options.value);\n    } else {\n      dataView = options.value;\n    }\n\n    await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.writeValueWithoutResponse(dataView));\n  }\n\n  async readDescriptor(options) {\n    const descriptor = await this.getDescriptor(options);\n    const value = await (descriptor === null || descriptor === void 0 ? void 0 : descriptor.readValue());\n    return {\n      value\n    };\n  }\n\n  async writeDescriptor(options) {\n    const descriptor = await this.getDescriptor(options);\n    let dataView;\n\n    if (typeof options.value === 'string') {\n      dataView = hexStringToDataView(options.value);\n    } else {\n      dataView = options.value;\n    }\n\n    await (descriptor === null || descriptor === void 0 ? void 0 : descriptor.writeValue(dataView));\n  }\n\n  async startNotifications(options) {\n    const characteristic = await this.getCharacteristic(options);\n    characteristic === null || characteristic === void 0 ? void 0 : characteristic.removeEventListener('characteristicvaluechanged', this.onCharacteristicValueChangedCallback);\n    characteristic === null || characteristic === void 0 ? void 0 : characteristic.addEventListener('characteristicvaluechanged', this.onCharacteristicValueChangedCallback);\n    await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.startNotifications());\n  }\n\n  onCharacteristicValueChanged(event) {\n    var _a, _b;\n\n    const characteristic = event.target;\n    const key = `notification|${(_a = characteristic.service) === null || _a === void 0 ? void 0 : _a.device.id}|${(_b = characteristic.service) === null || _b === void 0 ? void 0 : _b.uuid}|${characteristic.uuid}`;\n    this.notifyListeners(key, {\n      value: characteristic.value\n    });\n  }\n\n  async stopNotifications(options) {\n    const characteristic = await this.getCharacteristic(options);\n    await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.stopNotifications());\n  }\n\n  getFilters(options) {\n    var _a;\n\n    const filters = [];\n\n    for (const service of (_a = options === null || options === void 0 ? void 0 : options.services) !== null && _a !== void 0 ? _a : []) {\n      filters.push({\n        services: [service],\n        name: options === null || options === void 0 ? void 0 : options.name,\n        namePrefix: options === null || options === void 0 ? void 0 : options.namePrefix\n      });\n    }\n\n    if (((options === null || options === void 0 ? void 0 : options.name) || (options === null || options === void 0 ? void 0 : options.namePrefix)) && filters.length === 0) {\n      filters.push({\n        name: options.name,\n        namePrefix: options.namePrefix\n      });\n    }\n\n    return filters;\n  }\n\n  getDeviceFromMap(deviceId) {\n    const device = this.deviceMap.get(deviceId);\n\n    if (device === undefined) {\n      throw new Error('Device not found. Call \"requestDevice\", \"requestLEScan\" or \"getDevices\" first.');\n    }\n\n    return device;\n  }\n\n  getBleDevice(device) {\n    var _a;\n\n    const bleDevice = {\n      deviceId: device.id,\n      // use undefined instead of null if name is not available\n      name: (_a = device.name) !== null && _a !== void 0 ? _a : undefined,\n      uuids: device.uuids\n    };\n    return bleDevice;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["WebPlugin","hexStringToDataView","mapToObject","webUUIDToString","runWithTimeout","BluetoothLeWeb","constructor","Map","onAdvertisementReceived","bind","onDisconnected","onCharacteristicValueChanged","initialize","navigator","bluetooth","unavailable","isAvailable","getAvailability","isEnabled","value","enable","disable","startEnabledNotifications","stopEnabledNotifications","isLocationEnabled","openLocationSettings","openBluetoothSettings","openAppSettings","setDisplayStrings","requestDevice","options","filters","getFilters","device","length","undefined","optionalServices","acceptAllDevices","deviceMap","set","id","bleDevice","getBleDevice","requestLEScan","requestBleDeviceOptions","stopLEScan","discoveredDevices","removeEventListener","onAdvertisementReceivedCallback","addEventListener","scan","acceptAllAdvertisements","keepRepeatedDevices","allowDuplicates","event","deviceId","isNew","has","_a","result","localName","name","rssi","txPower","manufacturerData","serviceData","uuids","_b","map","notifyListeners","active","stop","getDevices","_options","devices","bleDevices","getConnectedDevices","filter","gatt","connected","connect","getDeviceFromMap","onDisconnectedCallback","timeoutError","Symbol","Error","timeout","DEFAULT_CONNECTION_TIMEOUT","error","disconnect","target","key","createBond","isBonded","getServices","services","getPrimaryServices","bleServices","service","characteristics","getCharacteristics","bleCharacteristics","characteristic","push","uuid","properties","getProperties","descriptors","getDescriptors","descriptor","broadcast","read","writeWithoutResponse","write","notify","indicate","authenticatedSignedWrites","reliableWrite","writableAuxiliaries","getCharacteristic","getPrimaryService","getDescriptor","readRssi","readValue","dataView","writeValueWithResponse","writeValueWithoutResponse","readDescriptor","writeDescriptor","writeValue","startNotifications","onCharacteristicValueChangedCallback","stopNotifications","namePrefix","get"],"sources":["/data/data/com.termux/files/home/Ionic/ExploringApp/node_modules/@capacitor-community/bluetooth-le/src/web.ts"],"sourcesContent":["import { WebPlugin } from '@capacitor/core';\n\nimport { hexStringToDataView, mapToObject, webUUIDToString } from './conversion';\nimport type {\n  BleCharacteristic,\n  BleCharacteristicProperties,\n  BleDescriptor,\n  BleService,\n  TimeoutOptions,\n  BleDevice,\n  BleServices,\n  BluetoothLePlugin,\n  BooleanResult,\n  DeviceIdOptions,\n  GetConnectedDevicesOptions,\n  GetDevicesOptions,\n  GetDevicesResult,\n  ReadDescriptorOptions,\n  ReadOptions,\n  ReadResult,\n  ReadRssiResult,\n  RequestBleDeviceOptions,\n  ScanResultInternal,\n  WriteOptions,\n  WriteDescriptorOptions,\n} from './definitions';\nimport { runWithTimeout } from './timeout';\n\nexport class BluetoothLeWeb extends WebPlugin implements BluetoothLePlugin {\n  private deviceMap = new Map<string, BluetoothDevice>();\n  private discoveredDevices = new Map<string, boolean>();\n  private scan: BluetoothLEScan | null = null;\n  private requestBleDeviceOptions: RequestBleDeviceOptions | undefined;\n  private DEFAULT_CONNECTION_TIMEOUT = 10000;\n\n  async initialize(): Promise<void> {\n    if (typeof navigator === 'undefined' || !navigator.bluetooth) {\n      throw this.unavailable('Web Bluetooth API not available in this browser.');\n    }\n    const isAvailable = await navigator.bluetooth.getAvailability();\n    if (!isAvailable) {\n      throw this.unavailable('No Bluetooth radio available.');\n    }\n  }\n\n  async isEnabled(): Promise<BooleanResult> {\n    // not available on web\n    return { value: true };\n  }\n\n  async enable(): Promise<void> {\n    throw this.unavailable('enable is not available on web.');\n  }\n\n  async disable(): Promise<void> {\n    throw this.unavailable('disable is not available on web.');\n  }\n\n  async startEnabledNotifications(): Promise<void> {\n    // not available on web\n  }\n\n  async stopEnabledNotifications(): Promise<void> {\n    // not available on web\n  }\n\n  async isLocationEnabled(): Promise<BooleanResult> {\n    throw this.unavailable('isLocationEnabled is not available on web.');\n  }\n\n  async openLocationSettings(): Promise<void> {\n    throw this.unavailable('openLocationSettings is not available on web.');\n  }\n\n  async openBluetoothSettings(): Promise<void> {\n    throw this.unavailable('openBluetoothSettings is not available on web.');\n  }\n\n  async openAppSettings(): Promise<void> {\n    throw this.unavailable('openAppSettings is not available on web.');\n  }\n\n  async setDisplayStrings(): Promise<void> {\n    // not available on web\n  }\n\n  async requestDevice(options?: RequestBleDeviceOptions): Promise<BleDevice> {\n    const filters = this.getFilters(options);\n    const device = await navigator.bluetooth.requestDevice({\n      filters: filters.length ? filters : undefined,\n      optionalServices: options?.optionalServices,\n      acceptAllDevices: filters.length === 0,\n    });\n    this.deviceMap.set(device.id, device);\n    const bleDevice = this.getBleDevice(device);\n    return bleDevice;\n  }\n\n  async requestLEScan(options?: RequestBleDeviceOptions): Promise<void> {\n    this.requestBleDeviceOptions = options;\n    const filters = this.getFilters(options);\n    await this.stopLEScan();\n    this.discoveredDevices = new Map<string, boolean>();\n    navigator.bluetooth.removeEventListener(\n      'advertisementreceived',\n      this.onAdvertisementReceivedCallback as EventListener\n    );\n    navigator.bluetooth.addEventListener('advertisementreceived', this.onAdvertisementReceivedCallback);\n    this.scan = await navigator.bluetooth.requestLEScan({\n      filters: filters.length ? filters : undefined,\n      acceptAllAdvertisements: filters.length === 0,\n      keepRepeatedDevices: options?.allowDuplicates,\n    });\n  }\n\n  private onAdvertisementReceivedCallback = this.onAdvertisementReceived.bind(this);\n\n  private onAdvertisementReceived(event: BluetoothAdvertisingEvent): void {\n    const deviceId = event.device.id;\n    this.deviceMap.set(deviceId, event.device);\n    const isNew = !this.discoveredDevices.has(deviceId);\n    if (isNew || this.requestBleDeviceOptions?.allowDuplicates) {\n      this.discoveredDevices.set(deviceId, true);\n      const device = this.getBleDevice(event.device);\n      const result: ScanResultInternal = {\n        device,\n        localName: device.name,\n        rssi: event.rssi,\n        txPower: event.txPower,\n        manufacturerData: mapToObject(event.manufacturerData),\n        serviceData: mapToObject(event.serviceData),\n        uuids: event.uuids?.map(webUUIDToString),\n      };\n      this.notifyListeners('onScanResult', result);\n    }\n  }\n\n  async stopLEScan(): Promise<void> {\n    if (this.scan?.active) {\n      this.scan.stop();\n    }\n    this.scan = null;\n  }\n\n  async getDevices(_options: GetDevicesOptions): Promise<GetDevicesResult> {\n    const devices = await navigator.bluetooth.getDevices();\n    const bleDevices = devices.map((device) => {\n      this.deviceMap.set(device.id, device);\n      const bleDevice = this.getBleDevice(device);\n      return bleDevice;\n    });\n    return { devices: bleDevices };\n  }\n\n  async getConnectedDevices(_options: GetConnectedDevicesOptions): Promise<GetDevicesResult> {\n    const devices = await navigator.bluetooth.getDevices();\n    const bleDevices = devices\n      .filter((device) => {\n        return device.gatt?.connected;\n      })\n      .map((device) => {\n        this.deviceMap.set(device.id, device);\n        const bleDevice = this.getBleDevice(device);\n        return bleDevice;\n      });\n    return { devices: bleDevices };\n  }\n\n  async connect(options: DeviceIdOptions & TimeoutOptions): Promise<void> {\n    const device = this.getDeviceFromMap(options.deviceId);\n    device.removeEventListener('gattserverdisconnected', this.onDisconnectedCallback);\n    device.addEventListener('gattserverdisconnected', this.onDisconnectedCallback);\n    const timeoutError = Symbol();\n    if (device.gatt === undefined) {\n      throw new Error('No gatt server available.');\n    }\n    try {\n      const timeout = options.timeout ?? this.DEFAULT_CONNECTION_TIMEOUT;\n      await runWithTimeout(device.gatt.connect(), timeout, timeoutError);\n    } catch (error) {\n      // cancel pending connect call, does not work yet in chromium because of a bug:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=684073\n      await device.gatt?.disconnect();\n      if (error === timeoutError) {\n        throw new Error('Connection timeout');\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  private onDisconnectedCallback = this.onDisconnected.bind(this);\n\n  private onDisconnected(event: Event): void {\n    const deviceId = (event.target as BluetoothDevice).id;\n    const key = `disconnected|${deviceId}`;\n    this.notifyListeners(key, null);\n  }\n\n  async createBond(_options: DeviceIdOptions): Promise<void> {\n    throw this.unavailable('createBond is not available on web.');\n  }\n\n  async isBonded(_options: DeviceIdOptions): Promise<BooleanResult> {\n    throw this.unavailable('isBonded is not available on web.');\n  }\n\n  async disconnect(options: DeviceIdOptions): Promise<void> {\n    this.getDeviceFromMap(options.deviceId).gatt?.disconnect();\n  }\n\n  async getServices(options: DeviceIdOptions): Promise<BleServices> {\n    const services = (await this.getDeviceFromMap(options.deviceId).gatt?.getPrimaryServices()) ?? [];\n    const bleServices: BleService[] = [];\n    for (const service of services) {\n      const characteristics = await service.getCharacteristics();\n      const bleCharacteristics: BleCharacteristic[] = [];\n      for (const characteristic of characteristics) {\n        bleCharacteristics.push({\n          uuid: characteristic.uuid,\n          properties: this.getProperties(characteristic),\n          descriptors: await this.getDescriptors(characteristic),\n        });\n      }\n      bleServices.push({ uuid: service.uuid, characteristics: bleCharacteristics });\n    }\n    return { services: bleServices };\n  }\n\n  private async getDescriptors(characteristic: BluetoothRemoteGATTCharacteristic): Promise<BleDescriptor[]> {\n    try {\n      const descriptors = await characteristic.getDescriptors();\n      return descriptors.map((descriptor) => ({\n        uuid: descriptor.uuid,\n      }));\n    } catch {\n      return [];\n    }\n  }\n\n  private getProperties(characteristic: BluetoothRemoteGATTCharacteristic): BleCharacteristicProperties {\n    return {\n      broadcast: characteristic.properties.broadcast,\n      read: characteristic.properties.read,\n      writeWithoutResponse: characteristic.properties.writeWithoutResponse,\n      write: characteristic.properties.write,\n      notify: characteristic.properties.notify,\n      indicate: characteristic.properties.indicate,\n      authenticatedSignedWrites: characteristic.properties.authenticatedSignedWrites,\n      reliableWrite: characteristic.properties.reliableWrite,\n      writableAuxiliaries: characteristic.properties.writableAuxiliaries,\n    };\n  }\n\n  private async getCharacteristic(\n    options: ReadOptions | WriteOptions\n  ): Promise<BluetoothRemoteGATTCharacteristic | undefined> {\n    const service = await this.getDeviceFromMap(options.deviceId).gatt?.getPrimaryService(options?.service);\n    return service?.getCharacteristic(options?.characteristic);\n  }\n\n  private async getDescriptor(\n    options: ReadDescriptorOptions | WriteDescriptorOptions\n  ): Promise<BluetoothRemoteGATTDescriptor | undefined> {\n    const characteristic = await this.getCharacteristic(options);\n    return characteristic?.getDescriptor(options?.descriptor);\n  }\n\n  async readRssi(_options: DeviceIdOptions): Promise<ReadRssiResult> {\n    throw this.unavailable('readRssi is not available on web.');\n  }\n\n  async read(options: ReadOptions): Promise<ReadResult> {\n    const characteristic = await this.getCharacteristic(options);\n    const value = await characteristic?.readValue();\n    return { value };\n  }\n\n  async write(options: WriteOptions): Promise<void> {\n    const characteristic = await this.getCharacteristic(options);\n    let dataView: DataView;\n    if (typeof options.value === 'string') {\n      dataView = hexStringToDataView(options.value);\n    } else {\n      dataView = options.value;\n    }\n    await characteristic?.writeValueWithResponse(dataView);\n  }\n\n  async writeWithoutResponse(options: WriteOptions): Promise<void> {\n    const characteristic = await this.getCharacteristic(options);\n    let dataView: DataView;\n    if (typeof options.value === 'string') {\n      dataView = hexStringToDataView(options.value);\n    } else {\n      dataView = options.value;\n    }\n    await characteristic?.writeValueWithoutResponse(dataView);\n  }\n\n  async readDescriptor(options: ReadDescriptorOptions): Promise<ReadResult> {\n    const descriptor = await this.getDescriptor(options);\n    const value = await descriptor?.readValue();\n    return { value };\n  }\n\n  async writeDescriptor(options: WriteDescriptorOptions): Promise<void> {\n    const descriptor = await this.getDescriptor(options);\n    let dataView: DataView;\n    if (typeof options.value === 'string') {\n      dataView = hexStringToDataView(options.value);\n    } else {\n      dataView = options.value;\n    }\n    await descriptor?.writeValue(dataView);\n  }\n\n  async startNotifications(options: ReadOptions): Promise<void> {\n    const characteristic = await this.getCharacteristic(options);\n    characteristic?.removeEventListener('characteristicvaluechanged', this.onCharacteristicValueChangedCallback);\n    characteristic?.addEventListener('characteristicvaluechanged', this.onCharacteristicValueChangedCallback);\n    await characteristic?.startNotifications();\n  }\n\n  private onCharacteristicValueChangedCallback = this.onCharacteristicValueChanged.bind(this);\n\n  private onCharacteristicValueChanged(event: Event): void {\n    const characteristic = event.target as BluetoothRemoteGATTCharacteristic;\n    const key = `notification|${characteristic.service?.device.id}|${characteristic.service?.uuid}|${characteristic.uuid}`;\n    this.notifyListeners(key, {\n      value: characteristic.value,\n    });\n  }\n\n  async stopNotifications(options: ReadOptions): Promise<void> {\n    const characteristic = await this.getCharacteristic(options);\n    await characteristic?.stopNotifications();\n  }\n\n  private getFilters(options?: RequestBleDeviceOptions): BluetoothLEScanFilter[] {\n    const filters: BluetoothLEScanFilter[] = [];\n    for (const service of options?.services ?? []) {\n      filters.push({\n        services: [service],\n        name: options?.name,\n        namePrefix: options?.namePrefix,\n      });\n    }\n    if ((options?.name || options?.namePrefix) && filters.length === 0) {\n      filters.push({\n        name: options.name,\n        namePrefix: options.namePrefix,\n      });\n    }\n    return filters;\n  }\n\n  private getDeviceFromMap(deviceId: string): BluetoothDevice {\n    const device = this.deviceMap.get(deviceId);\n    if (device === undefined) {\n      throw new Error('Device not found. Call \"requestDevice\", \"requestLEScan\" or \"getDevices\" first.');\n    }\n    return device;\n  }\n\n  private getBleDevice(device: BluetoothDevice): BleDevice {\n    const bleDevice: BleDevice = {\n      deviceId: device.id,\n      // use undefined instead of null if name is not available\n      name: device.name ?? undefined,\n      uuids: device.uuids,\n    };\n    return bleDevice;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}