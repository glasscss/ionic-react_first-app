{"ast":null,"code":"import _createForOfIteratorHelper from \"/data/data/com.termux/files/home/Ionic/ExploringApp/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/data/data/com.termux/files/home/Ionic/ExploringApp/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/data/data/com.termux/files/home/Ionic/ExploringApp/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/data/data/com.termux/files/home/Ionic/ExploringApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/data/data/com.termux/files/home/Ionic/ExploringApp/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/data/data/com.termux/files/home/Ionic/ExploringApp/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/data/data/com.termux/files/home/Ionic/ExploringApp/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/data/data/com.termux/files/home/Ionic/ExploringApp/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { WebPlugin } from '@capacitor/core';\n\nfunction resolve(path) {\n  var posix = path.split('/').filter(function (item) {\n    return item !== '.';\n  });\n  var newPosix = [];\n  posix.forEach(function (item) {\n    if (item === '..' && newPosix.length > 0 && newPosix[newPosix.length - 1] !== '..') {\n      newPosix.pop();\n    } else {\n      newPosix.push(item);\n    }\n  });\n  return newPosix.join('/');\n}\n\nfunction isPathParent(parent, children) {\n  parent = resolve(parent);\n  children = resolve(children);\n  var pathsA = parent.split('/');\n  var pathsB = children.split('/');\n  return parent !== children && pathsA.every(function (value, index) {\n    return value === pathsB[index];\n  });\n}\n\nexport var FilesystemWeb = /*#__PURE__*/function (_WebPlugin) {\n  _inherits(FilesystemWeb, _WebPlugin);\n\n  var _super = _createSuper(FilesystemWeb);\n\n  function FilesystemWeb() {\n    var _this;\n\n    _classCallCheck(this, FilesystemWeb);\n\n    _this = _super.apply(this, arguments);\n    _this.DB_VERSION = 1;\n    _this.DB_NAME = 'Disc';\n    _this._writeCmds = ['add', 'put', 'delete'];\n    return _this;\n  }\n\n  _createClass(FilesystemWeb, [{\n    key: \"initDb\",\n    value: function () {\n      var _initDb = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this._db !== undefined)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this._db);\n\n              case 2:\n                if ('indexedDB' in window) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw this.unavailable(\"This browser doesn't support IndexedDB\");\n\n              case 4:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var request = indexedDB.open(_this2.DB_NAME, _this2.DB_VERSION);\n                  request.onupgradeneeded = FilesystemWeb.doUpgrade;\n\n                  request.onsuccess = function () {\n                    _this2._db = request.result;\n                    resolve(request.result);\n                  };\n\n                  request.onerror = function () {\n                    return reject(request.error);\n                  };\n\n                  request.onblocked = function () {\n                    console.warn('db blocked');\n                  };\n                }));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function initDb() {\n        return _initDb.apply(this, arguments);\n      }\n\n      return initDb;\n    }()\n  }, {\n    key: \"dbRequest\",\n    value: function () {\n      var _dbRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(cmd, args) {\n        var readFlag;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n                return _context2.abrupt(\"return\", this.initDb().then(function (conn) {\n                  return new Promise(function (resolve, reject) {\n                    var tx = conn.transaction(['FileStorage'], readFlag);\n                    var store = tx.objectStore('FileStorage');\n                    var req = store[cmd].apply(store, _toConsumableArray(args));\n\n                    req.onsuccess = function () {\n                      return resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                      return reject(req.error);\n                    };\n                  });\n                }));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function dbRequest(_x, _x2) {\n        return _dbRequest.apply(this, arguments);\n      }\n\n      return dbRequest;\n    }()\n  }, {\n    key: \"dbIndexRequest\",\n    value: function () {\n      var _dbIndexRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(indexName, cmd, args) {\n        var readFlag;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n                return _context3.abrupt(\"return\", this.initDb().then(function (conn) {\n                  return new Promise(function (resolve, reject) {\n                    var tx = conn.transaction(['FileStorage'], readFlag);\n                    var store = tx.objectStore('FileStorage');\n                    var index = store.index(indexName);\n                    var req = index[cmd].apply(index, _toConsumableArray(args));\n\n                    req.onsuccess = function () {\n                      return resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                      return reject(req.error);\n                    };\n                  });\n                }));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function dbIndexRequest(_x3, _x4, _x5) {\n        return _dbIndexRequest.apply(this, arguments);\n      }\n\n      return dbIndexRequest;\n    }()\n  }, {\n    key: \"getPath\",\n    value: function getPath(directory, uriPath) {\n      var cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n      var fsPath = '';\n      if (directory !== undefined) fsPath += '/' + directory;\n      if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n      return fsPath;\n    }\n  }, {\n    key: \"clear\",\n    value: function () {\n      var _clear = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var conn, tx, store;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.initDb();\n\n              case 2:\n                conn = _context4.sent;\n                tx = conn.transaction(['FileStorage'], 'readwrite');\n                store = tx.objectStore('FileStorage');\n                store.clear();\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function clear() {\n        return _clear.apply(this, arguments);\n      }\n\n      return clear;\n    }()\n    /**\n     * Read a file from disk\n     * @param options options for the file read\n     * @return a promise that resolves with the read file data result\n     */\n\n  }, {\n    key: \"readFile\",\n    value: function () {\n      var _readFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(options) {\n        var path, entry;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path); // const encoding = options.encoding;\n\n                _context5.next = 3;\n                return this.dbRequest('get', [path]);\n\n              case 3:\n                entry = _context5.sent;\n\n                if (!(entry === undefined)) {\n                  _context5.next = 6;\n                  break;\n                }\n\n                throw Error('File does not exist.');\n\n              case 6:\n                return _context5.abrupt(\"return\", {\n                  data: entry.content ? entry.content : ''\n                });\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function readFile(_x6) {\n        return _readFile.apply(this, arguments);\n      }\n\n      return readFile;\n    }()\n    /**\n     * Write a file to disk in the specified location on device\n     * @param options options for the file write\n     * @return a promise that resolves with the file write result\n     */\n\n  }, {\n    key: \"writeFile\",\n    value: function () {\n      var _writeFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(options) {\n        var path, data, doRecursive, occupiedEntry, encoding, parentPath, parentEntry, subDirIndex, parentArgPath, now, pathObj;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                data = options.data;\n                doRecursive = options.recursive;\n                _context6.next = 5;\n                return this.dbRequest('get', [path]);\n\n              case 5:\n                occupiedEntry = _context6.sent;\n\n                if (!(occupiedEntry && occupiedEntry.type === 'directory')) {\n                  _context6.next = 8;\n                  break;\n                }\n\n                throw Error('The supplied path is a directory.');\n\n              case 8:\n                encoding = options.encoding;\n                parentPath = path.substr(0, path.lastIndexOf('/'));\n                _context6.next = 12;\n                return this.dbRequest('get', [parentPath]);\n\n              case 12:\n                parentEntry = _context6.sent;\n\n                if (!(parentEntry === undefined)) {\n                  _context6.next = 19;\n                  break;\n                }\n\n                subDirIndex = parentPath.indexOf('/', 1);\n\n                if (!(subDirIndex !== -1)) {\n                  _context6.next = 19;\n                  break;\n                }\n\n                parentArgPath = parentPath.substr(subDirIndex);\n                _context6.next = 19;\n                return this.mkdir({\n                  path: parentArgPath,\n                  directory: options.directory,\n                  recursive: doRecursive\n                });\n\n              case 19:\n                now = Date.now();\n                pathObj = {\n                  path: path,\n                  folder: parentPath,\n                  type: 'file',\n                  size: data.length,\n                  ctime: now,\n                  mtime: now,\n                  content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data\n                };\n                _context6.next = 23;\n                return this.dbRequest('put', [pathObj]);\n\n              case 23:\n                return _context6.abrupt(\"return\", {\n                  uri: pathObj.path\n                });\n\n              case 24:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function writeFile(_x7) {\n        return _writeFile.apply(this, arguments);\n      }\n\n      return writeFile;\n    }()\n    /**\n     * Append to a file on disk in the specified location on device\n     * @param options options for the file append\n     * @return a promise that resolves with the file write result\n     */\n\n  }, {\n    key: \"appendFile\",\n    value: function () {\n      var _appendFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(options) {\n        var path, data, parentPath, now, ctime, occupiedEntry, parentEntry, subDirIndex, parentArgPath, pathObj;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                data = options.data; // const encoding = options.encoding;\n\n                parentPath = path.substr(0, path.lastIndexOf('/'));\n                now = Date.now();\n                ctime = now;\n                _context7.next = 7;\n                return this.dbRequest('get', [path]);\n\n              case 7:\n                occupiedEntry = _context7.sent;\n\n                if (!(occupiedEntry && occupiedEntry.type === 'directory')) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                throw Error('The supplied path is a directory.');\n\n              case 10:\n                _context7.next = 12;\n                return this.dbRequest('get', [parentPath]);\n\n              case 12:\n                parentEntry = _context7.sent;\n\n                if (!(parentEntry === undefined)) {\n                  _context7.next = 19;\n                  break;\n                }\n\n                subDirIndex = parentPath.indexOf('/', 1);\n\n                if (!(subDirIndex !== -1)) {\n                  _context7.next = 19;\n                  break;\n                }\n\n                parentArgPath = parentPath.substr(subDirIndex);\n                _context7.next = 19;\n                return this.mkdir({\n                  path: parentArgPath,\n                  directory: options.directory,\n                  recursive: true\n                });\n\n              case 19:\n                if (occupiedEntry !== undefined) {\n                  data = occupiedEntry.content + data;\n                  ctime = occupiedEntry.ctime;\n                }\n\n                pathObj = {\n                  path: path,\n                  folder: parentPath,\n                  type: 'file',\n                  size: data.length,\n                  ctime: ctime,\n                  mtime: now,\n                  content: data\n                };\n                _context7.next = 23;\n                return this.dbRequest('put', [pathObj]);\n\n              case 23:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function appendFile(_x8) {\n        return _appendFile.apply(this, arguments);\n      }\n\n      return appendFile;\n    }()\n    /**\n     * Delete a file from disk\n     * @param options options for the file delete\n     * @return a promise that resolves with the deleted file data result\n     */\n\n  }, {\n    key: \"deleteFile\",\n    value: function () {\n      var _deleteFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(options) {\n        var path, entry, entries;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                _context8.next = 3;\n                return this.dbRequest('get', [path]);\n\n              case 3:\n                entry = _context8.sent;\n\n                if (!(entry === undefined)) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                throw Error('File does not exist.');\n\n              case 6:\n                _context8.next = 8;\n                return this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n\n              case 8:\n                entries = _context8.sent;\n\n                if (!(entries.length !== 0)) {\n                  _context8.next = 11;\n                  break;\n                }\n\n                throw Error('Folder is not empty.');\n\n              case 11:\n                _context8.next = 13;\n                return this.dbRequest('delete', [path]);\n\n              case 13:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function deleteFile(_x9) {\n        return _deleteFile.apply(this, arguments);\n      }\n\n      return deleteFile;\n    }()\n    /**\n     * Create a directory.\n     * @param options options for the mkdir\n     * @return a promise that resolves with the mkdir result\n     */\n\n  }, {\n    key: \"mkdir\",\n    value: function () {\n      var _mkdir = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(options) {\n        var path, doRecursive, parentPath, depth, parentEntry, occupiedEntry, parentArgPath, now, pathObj;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                doRecursive = options.recursive;\n                parentPath = path.substr(0, path.lastIndexOf('/'));\n                depth = (path.match(/\\//g) || []).length;\n                _context9.next = 6;\n                return this.dbRequest('get', [parentPath]);\n\n              case 6:\n                parentEntry = _context9.sent;\n                _context9.next = 9;\n                return this.dbRequest('get', [path]);\n\n              case 9:\n                occupiedEntry = _context9.sent;\n\n                if (!(depth === 1)) {\n                  _context9.next = 12;\n                  break;\n                }\n\n                throw Error('Cannot create Root directory');\n\n              case 12:\n                if (!(occupiedEntry !== undefined)) {\n                  _context9.next = 14;\n                  break;\n                }\n\n                throw Error('Current directory does already exist.');\n\n              case 14:\n                if (!(!doRecursive && depth !== 2 && parentEntry === undefined)) {\n                  _context9.next = 16;\n                  break;\n                }\n\n                throw Error('Parent directory must exist');\n\n              case 16:\n                if (!(doRecursive && depth !== 2 && parentEntry === undefined)) {\n                  _context9.next = 20;\n                  break;\n                }\n\n                parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n                _context9.next = 20;\n                return this.mkdir({\n                  path: parentArgPath,\n                  directory: options.directory,\n                  recursive: doRecursive\n                });\n\n              case 20:\n                now = Date.now();\n                pathObj = {\n                  path: path,\n                  folder: parentPath,\n                  type: 'directory',\n                  size: 0,\n                  ctime: now,\n                  mtime: now\n                };\n                _context9.next = 24;\n                return this.dbRequest('put', [pathObj]);\n\n              case 24:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function mkdir(_x10) {\n        return _mkdir.apply(this, arguments);\n      }\n\n      return mkdir;\n    }()\n    /**\n     * Remove a directory\n     * @param options the options for the directory remove\n     */\n\n  }, {\n    key: \"rmdir\",\n    value: function () {\n      var _rmdir = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(options) {\n        var path, directory, recursive, fullPath, entry, readDirResult, _iterator, _step, _entry, entryPath, entryObj;\n\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                path = options.path, directory = options.directory, recursive = options.recursive;\n                fullPath = this.getPath(directory, path);\n                _context10.next = 4;\n                return this.dbRequest('get', [fullPath]);\n\n              case 4:\n                entry = _context10.sent;\n\n                if (!(entry === undefined)) {\n                  _context10.next = 7;\n                  break;\n                }\n\n                throw Error('Folder does not exist.');\n\n              case 7:\n                if (!(entry.type !== 'directory')) {\n                  _context10.next = 9;\n                  break;\n                }\n\n                throw Error('Requested path is not a directory');\n\n              case 9:\n                _context10.next = 11;\n                return this.readdir({\n                  path: path,\n                  directory: directory\n                });\n\n              case 11:\n                readDirResult = _context10.sent;\n\n                if (!(readDirResult.files.length !== 0 && !recursive)) {\n                  _context10.next = 14;\n                  break;\n                }\n\n                throw Error('Folder is not empty');\n\n              case 14:\n                _iterator = _createForOfIteratorHelper(readDirResult.files);\n                _context10.prev = 15;\n\n                _iterator.s();\n\n              case 17:\n                if ((_step = _iterator.n()).done) {\n                  _context10.next = 32;\n                  break;\n                }\n\n                _entry = _step.value;\n                entryPath = \"\".concat(path, \"/\").concat(_entry);\n                _context10.next = 22;\n                return this.stat({\n                  path: entryPath,\n                  directory: directory\n                });\n\n              case 22:\n                entryObj = _context10.sent;\n\n                if (!(entryObj.type === 'file')) {\n                  _context10.next = 28;\n                  break;\n                }\n\n                _context10.next = 26;\n                return this.deleteFile({\n                  path: entryPath,\n                  directory: directory\n                });\n\n              case 26:\n                _context10.next = 30;\n                break;\n\n              case 28:\n                _context10.next = 30;\n                return this.rmdir({\n                  path: entryPath,\n                  directory: directory,\n                  recursive: recursive\n                });\n\n              case 30:\n                _context10.next = 17;\n                break;\n\n              case 32:\n                _context10.next = 37;\n                break;\n\n              case 34:\n                _context10.prev = 34;\n                _context10.t0 = _context10[\"catch\"](15);\n\n                _iterator.e(_context10.t0);\n\n              case 37:\n                _context10.prev = 37;\n\n                _iterator.f();\n\n                return _context10.finish(37);\n\n              case 40:\n                _context10.next = 42;\n                return this.dbRequest('delete', [fullPath]);\n\n              case 42:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[15, 34, 37, 40]]);\n      }));\n\n      function rmdir(_x11) {\n        return _rmdir.apply(this, arguments);\n      }\n\n      return rmdir;\n    }()\n    /**\n     * Return a list of files from the directory (not recursive)\n     * @param options the options for the readdir operation\n     * @return a promise that resolves with the readdir directory listing result\n     */\n\n  }, {\n    key: \"readdir\",\n    value: function () {\n      var _readdir = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(options) {\n        var path, entry, entries, names;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                _context11.next = 3;\n                return this.dbRequest('get', [path]);\n\n              case 3:\n                entry = _context11.sent;\n\n                if (!(options.path !== '' && entry === undefined)) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                throw Error('Folder does not exist.');\n\n              case 6:\n                _context11.next = 8;\n                return this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n\n              case 8:\n                entries = _context11.sent;\n                names = entries.map(function (e) {\n                  return e.substring(path.length + 1);\n                });\n                return _context11.abrupt(\"return\", {\n                  files: names\n                });\n\n              case 11:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function readdir(_x12) {\n        return _readdir.apply(this, arguments);\n      }\n\n      return readdir;\n    }()\n    /**\n     * Return full File URI for a path and directory\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n\n  }, {\n    key: \"getUri\",\n    value: function () {\n      var _getUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(options) {\n        var path, entry;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                _context12.next = 3;\n                return this.dbRequest('get', [path]);\n\n              case 3:\n                entry = _context12.sent;\n\n                if (!(entry === undefined)) {\n                  _context12.next = 8;\n                  break;\n                }\n\n                _context12.next = 7;\n                return this.dbRequest('get', [path + '/']);\n\n              case 7:\n                entry = _context12.sent;\n\n              case 8:\n                return _context12.abrupt(\"return\", {\n                  uri: (entry === null || entry === void 0 ? void 0 : entry.path) || path\n                });\n\n              case 9:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getUri(_x13) {\n        return _getUri.apply(this, arguments);\n      }\n\n      return getUri;\n    }()\n    /**\n     * Return data about a file\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n\n  }, {\n    key: \"stat\",\n    value: function () {\n      var _stat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(options) {\n        var path, entry;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                path = this.getPath(options.directory, options.path);\n                _context13.next = 3;\n                return this.dbRequest('get', [path]);\n\n              case 3:\n                entry = _context13.sent;\n\n                if (!(entry === undefined)) {\n                  _context13.next = 8;\n                  break;\n                }\n\n                _context13.next = 7;\n                return this.dbRequest('get', [path + '/']);\n\n              case 7:\n                entry = _context13.sent;\n\n              case 8:\n                if (!(entry === undefined)) {\n                  _context13.next = 10;\n                  break;\n                }\n\n                throw Error('Entry does not exist.');\n\n              case 10:\n                return _context13.abrupt(\"return\", {\n                  type: entry.type,\n                  size: entry.size,\n                  ctime: entry.ctime,\n                  mtime: entry.mtime,\n                  uri: entry.path\n                });\n\n              case 11:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function stat(_x14) {\n        return _stat.apply(this, arguments);\n      }\n\n      return stat;\n    }()\n    /**\n     * Rename a file or directory\n     * @param options the options for the rename operation\n     * @return a promise that resolves with the rename result\n     */\n\n  }, {\n    key: \"rename\",\n    value: function () {\n      var _rename = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(options) {\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                return _context14.abrupt(\"return\", this._copy(options, true));\n\n              case 1:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function rename(_x15) {\n        return _rename.apply(this, arguments);\n      }\n\n      return rename;\n    }()\n    /**\n     * Copy a file or directory\n     * @param options the options for the copy operation\n     * @return a promise that resolves with the copy result\n     */\n\n  }, {\n    key: \"copy\",\n    value: function () {\n      var _copy2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(options) {\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                return _context15.abrupt(\"return\", this._copy(options, false));\n\n              case 1:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function copy(_x16) {\n        return _copy2.apply(this, arguments);\n      }\n\n      return copy;\n    }()\n  }, {\n    key: \"requestPermissions\",\n    value: function () {\n      var _requestPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                return _context16.abrupt(\"return\", {\n                  publicStorage: 'granted'\n                });\n\n              case 1:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16);\n      }));\n\n      function requestPermissions() {\n        return _requestPermissions.apply(this, arguments);\n      }\n\n      return requestPermissions;\n    }()\n  }, {\n    key: \"checkPermissions\",\n    value: function () {\n      var _checkPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                return _context17.abrupt(\"return\", {\n                  publicStorage: 'granted'\n                });\n\n              case 1:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17);\n      }));\n\n      function checkPermissions() {\n        return _checkPermissions.apply(this, arguments);\n      }\n\n      return checkPermissions;\n    }()\n    /**\n     * Function that can perform a copy or a rename\n     * @param options the options for the rename operation\n     * @param doRename whether to perform a rename or copy operation\n     * @return a promise that resolves with the result\n     */\n\n  }, {\n    key: \"_copy\",\n    value: function () {\n      var _copy3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(options) {\n        var _this3 = this;\n\n        var doRename,\n            toDirectory,\n            to,\n            from,\n            fromDirectory,\n            fromPath,\n            toPath,\n            toObj,\n            toPathComponents,\n            _toPath,\n            toParentDirectory,\n            fromObj,\n            updateTime,\n            ctime,\n            file,\n            contents,\n            _iterator2,\n            _step2,\n            filename,\n            _args19 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                doRename = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : false;\n                toDirectory = options.toDirectory;\n                to = options.to, from = options.from, fromDirectory = options.directory;\n\n                if (!(!to || !from)) {\n                  _context19.next = 5;\n                  break;\n                }\n\n                throw Error('Both to and from must be provided');\n\n              case 5:\n                // If no \"to\" directory is provided, use the \"from\" directory\n                if (!toDirectory) {\n                  toDirectory = fromDirectory;\n                }\n\n                fromPath = this.getPath(fromDirectory, from);\n                toPath = this.getPath(toDirectory, to); // Test that the \"to\" and \"from\" locations are different\n\n                if (!(fromPath === toPath)) {\n                  _context19.next = 10;\n                  break;\n                }\n\n                return _context19.abrupt(\"return\");\n\n              case 10:\n                if (!isPathParent(fromPath, toPath)) {\n                  _context19.next = 12;\n                  break;\n                }\n\n                throw Error('To path cannot contain the from path');\n\n              case 12:\n                _context19.prev = 12;\n                _context19.next = 15;\n                return this.stat({\n                  path: to,\n                  directory: toDirectory\n                });\n\n              case 15:\n                toObj = _context19.sent;\n                _context19.next = 29;\n                break;\n\n              case 18:\n                _context19.prev = 18;\n                _context19.t0 = _context19[\"catch\"](12);\n                // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n                toPathComponents = to.split('/');\n                toPathComponents.pop();\n                _toPath = toPathComponents.join('/'); // Check the containing directory of the \"to\" location exists\n\n                if (!(toPathComponents.length > 0)) {\n                  _context19.next = 29;\n                  break;\n                }\n\n                _context19.next = 26;\n                return this.stat({\n                  path: _toPath,\n                  directory: toDirectory\n                });\n\n              case 26:\n                toParentDirectory = _context19.sent;\n\n                if (!(toParentDirectory.type !== 'directory')) {\n                  _context19.next = 29;\n                  break;\n                }\n\n                throw new Error('Parent directory of the to path is a file');\n\n              case 29:\n                if (!(toObj && toObj.type === 'directory')) {\n                  _context19.next = 31;\n                  break;\n                }\n\n                throw new Error('Cannot overwrite a directory with a file');\n\n              case 31:\n                _context19.next = 33;\n                return this.stat({\n                  path: from,\n                  directory: fromDirectory\n                });\n\n              case 33:\n                fromObj = _context19.sent;\n\n                // Set the mtime/ctime of the supplied path\n                updateTime = /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(path, ctime, mtime) {\n                    var fullPath, entry;\n                    return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n                      while (1) {\n                        switch (_context18.prev = _context18.next) {\n                          case 0:\n                            fullPath = _this3.getPath(toDirectory, path);\n                            _context18.next = 3;\n                            return _this3.dbRequest('get', [fullPath]);\n\n                          case 3:\n                            entry = _context18.sent;\n                            entry.ctime = ctime;\n                            entry.mtime = mtime;\n                            _context18.next = 8;\n                            return _this3.dbRequest('put', [entry]);\n\n                          case 8:\n                          case \"end\":\n                            return _context18.stop();\n                        }\n                      }\n                    }, _callee18);\n                  }));\n\n                  return function updateTime(_x18, _x19, _x20) {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n                _context19.t1 = fromObj.type;\n                _context19.next = _context19.t1 === 'file' ? 39 : _context19.t1 === 'directory' ? 51 : 86;\n                break;\n\n              case 39:\n                _context19.next = 41;\n                return this.readFile({\n                  path: from,\n                  directory: fromDirectory\n                });\n\n              case 41:\n                file = _context19.sent;\n\n                if (!doRename) {\n                  _context19.next = 45;\n                  break;\n                }\n\n                _context19.next = 45;\n                return this.deleteFile({\n                  path: from,\n                  directory: fromDirectory\n                });\n\n              case 45:\n                _context19.next = 47;\n                return this.writeFile({\n                  path: to,\n                  directory: toDirectory,\n                  data: file.data\n                });\n\n              case 47:\n                if (!doRename) {\n                  _context19.next = 50;\n                  break;\n                }\n\n                _context19.next = 50;\n                return updateTime(to, ctime, fromObj.mtime);\n\n              case 50:\n                return _context19.abrupt(\"return\");\n\n              case 51:\n                if (!toObj) {\n                  _context19.next = 53;\n                  break;\n                }\n\n                throw Error('Cannot move a directory over an existing object');\n\n              case 53:\n                _context19.prev = 53;\n                _context19.next = 56;\n                return this.mkdir({\n                  path: to,\n                  directory: toDirectory,\n                  recursive: false\n                });\n\n              case 56:\n                if (!doRename) {\n                  _context19.next = 59;\n                  break;\n                }\n\n                _context19.next = 59;\n                return updateTime(to, ctime, fromObj.mtime);\n\n              case 59:\n                _context19.next = 63;\n                break;\n\n              case 61:\n                _context19.prev = 61;\n                _context19.t2 = _context19[\"catch\"](53);\n\n              case 63:\n                _context19.next = 65;\n                return this.readdir({\n                  path: from,\n                  directory: fromDirectory\n                });\n\n              case 65:\n                contents = _context19.sent.files;\n                _iterator2 = _createForOfIteratorHelper(contents);\n                _context19.prev = 67;\n\n                _iterator2.s();\n\n              case 69:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context19.next = 75;\n                  break;\n                }\n\n                filename = _step2.value;\n                _context19.next = 73;\n                return this._copy({\n                  from: \"\".concat(from, \"/\").concat(filename),\n                  to: \"\".concat(to, \"/\").concat(filename),\n                  directory: fromDirectory,\n                  toDirectory: toDirectory\n                }, doRename);\n\n              case 73:\n                _context19.next = 69;\n                break;\n\n              case 75:\n                _context19.next = 80;\n                break;\n\n              case 77:\n                _context19.prev = 77;\n                _context19.t3 = _context19[\"catch\"](67);\n\n                _iterator2.e(_context19.t3);\n\n              case 80:\n                _context19.prev = 80;\n\n                _iterator2.f();\n\n                return _context19.finish(80);\n\n              case 83:\n                if (!doRename) {\n                  _context19.next = 86;\n                  break;\n                }\n\n                _context19.next = 86;\n                return this.rmdir({\n                  path: from,\n                  directory: fromDirectory\n                });\n\n              case 86:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this, [[12, 18], [53, 61], [67, 77, 80, 83]]);\n      }));\n\n      function _copy(_x17) {\n        return _copy3.apply(this, arguments);\n      }\n\n      return _copy;\n    }()\n  }], [{\n    key: \"doUpgrade\",\n    value: function doUpgrade(event) {\n      var eventTarget = event.target;\n      var db = eventTarget.result;\n\n      switch (event.oldVersion) {\n        case 0:\n        case 1:\n        default:\n          {\n            if (db.objectStoreNames.contains('FileStorage')) {\n              db.deleteObjectStore('FileStorage');\n            }\n\n            var store = db.createObjectStore('FileStorage', {\n              keyPath: 'path'\n            });\n            store.createIndex('by_folder', 'folder');\n          }\n      }\n    }\n  }]);\n\n  return FilesystemWeb;\n}(WebPlugin);\nFilesystemWeb._debug = true;","map":{"version":3,"mappings":"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","names":["WebPlugin","resolve","path","posix","split","filter","item","newPosix","forEach","length","pop","push","join","isPathParent","parent","children","pathsA","pathsB","every","value","index","FilesystemWeb","_db","undefined","window","unavailable","Promise","reject","request","indexedDB","open","DB_NAME","DB_VERSION","onupgradeneeded","doUpgrade","onsuccess","result","onerror","error","onblocked","console","warn","cmd","args","readFlag","_writeCmds","indexOf","initDb","then","conn","tx","transaction","store","objectStore","req","indexName","directory","uriPath","cleanedUriPath","replace","fsPath","clear","options","getPath","dbRequest","entry","Error","data","content","doRecursive","recursive","occupiedEntry","type","encoding","parentPath","substr","lastIndexOf","parentEntry","subDirIndex","parentArgPath","mkdir","now","Date","pathObj","folder","size","ctime","mtime","uri","dbIndexRequest","IDBKeyRange","only","entries","depth","match","fullPath","readdir","readDirResult","files","entryPath","stat","entryObj","deleteFile","rmdir","names","map","e","substring","_copy","publicStorage","doRename","toDirectory","to","from","fromDirectory","fromPath","toPath","toObj","toPathComponents","toParentDirectory","fromObj","updateTime","readFile","file","writeFile","contents","filename","event","eventTarget","target","db","oldVersion","objectStoreNames","contains","deleteObjectStore","createObjectStore","keyPath","createIndex"],"sources":["/data/data/com.termux/files/home/Ionic/ExploringApp/node_modules/@capacitor/filesystem/src/web.ts"],"sourcesContent":["import { WebPlugin } from '@capacitor/core';\n\nimport type {\n  AppendFileOptions,\n  CopyOptions,\n  DeleteFileOptions,\n  FilesystemPlugin,\n  GetUriOptions,\n  GetUriResult,\n  MkdirOptions,\n  PermissionStatus,\n  ReadFileOptions,\n  ReadFileResult,\n  ReaddirOptions,\n  ReaddirResult,\n  RenameOptions,\n  RmdirOptions,\n  StatOptions,\n  StatResult,\n  WriteFileOptions,\n  WriteFileResult,\n  Directory,\n} from './definitions';\n\nfunction resolve(path: string): string {\n  const posix = path.split('/').filter(item => item !== '.');\n  const newPosix: string[] = [];\n\n  posix.forEach(item => {\n    if (\n      item === '..' &&\n      newPosix.length > 0 &&\n      newPosix[newPosix.length - 1] !== '..'\n    ) {\n      newPosix.pop();\n    } else {\n      newPosix.push(item);\n    }\n  });\n\n  return newPosix.join('/');\n}\nfunction isPathParent(parent: string, children: string): boolean {\n  parent = resolve(parent);\n  children = resolve(children);\n  const pathsA = parent.split('/');\n  const pathsB = children.split('/');\n\n  return (\n    parent !== children &&\n    pathsA.every((value, index) => value === pathsB[index])\n  );\n}\n\nexport class FilesystemWeb extends WebPlugin implements FilesystemPlugin {\n  DB_VERSION = 1;\n  DB_NAME = 'Disc';\n\n  private _writeCmds: string[] = ['add', 'put', 'delete'];\n  private _db?: IDBDatabase;\n  static _debug = true;\n  async initDb(): Promise<IDBDatabase> {\n    if (this._db !== undefined) {\n      return this._db;\n    }\n    if (!('indexedDB' in window)) {\n      throw this.unavailable(\"This browser doesn't support IndexedDB\");\n    }\n\n    return new Promise<IDBDatabase>((resolve, reject) => {\n      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n      request.onupgradeneeded = FilesystemWeb.doUpgrade;\n      request.onsuccess = () => {\n        this._db = request.result;\n        resolve(request.result);\n      };\n      request.onerror = () => reject(request.error);\n      request.onblocked = () => {\n        console.warn('db blocked');\n      };\n    });\n  }\n\n  static doUpgrade(event: IDBVersionChangeEvent): void {\n    const eventTarget = event.target as IDBOpenDBRequest;\n    const db = eventTarget.result;\n    switch (event.oldVersion) {\n      case 0:\n      case 1:\n      default: {\n        if (db.objectStoreNames.contains('FileStorage')) {\n          db.deleteObjectStore('FileStorage');\n        }\n        const store = db.createObjectStore('FileStorage', { keyPath: 'path' });\n        store.createIndex('by_folder', 'folder');\n      }\n    }\n  }\n\n  async dbRequest(cmd: string, args: any[]): Promise<any> {\n    const readFlag =\n      this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then((conn: IDBDatabase) => {\n      return new Promise<IDBObjectStore>((resolve, reject) => {\n        const tx: IDBTransaction = conn.transaction(['FileStorage'], readFlag);\n        const store: any = tx.objectStore('FileStorage');\n        const req = store[cmd](...args);\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  async dbIndexRequest(\n    indexName: string,\n    cmd: string,\n    args: [any],\n  ): Promise<any> {\n    const readFlag =\n      this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then((conn: IDBDatabase) => {\n      return new Promise<IDBObjectStore>((resolve, reject) => {\n        const tx: IDBTransaction = conn.transaction(['FileStorage'], readFlag);\n        const store: IDBObjectStore = tx.objectStore('FileStorage');\n        const index: any = store.index(indexName);\n        const req = index[cmd](...args) as any;\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  private getPath(\n    directory: Directory | undefined,\n    uriPath: string | undefined,\n  ): string {\n    const cleanedUriPath =\n      uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n    let fsPath = '';\n    if (directory !== undefined) fsPath += '/' + directory;\n    if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n    return fsPath;\n  }\n\n  async clear(): Promise<void> {\n    const conn: IDBDatabase = await this.initDb();\n    const tx: IDBTransaction = conn.transaction(['FileStorage'], 'readwrite');\n    const store: IDBObjectStore = tx.objectStore('FileStorage');\n    store.clear();\n  }\n\n  /**\n   * Read a file from disk\n   * @param options options for the file read\n   * @return a promise that resolves with the read file data result\n   */\n  async readFile(options: ReadFileOptions): Promise<ReadFileResult> {\n    const path: string = this.getPath(options.directory, options.path);\n    // const encoding = options.encoding;\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) throw Error('File does not exist.');\n    return { data: entry.content ? entry.content : '' };\n  }\n\n  /**\n   * Write a file to disk in the specified location on device\n   * @param options options for the file write\n   * @return a promise that resolves with the file write result\n   */\n  async writeFile(options: WriteFileOptions): Promise<WriteFileResult> {\n    const path: string = this.getPath(options.directory, options.path);\n    const data = options.data;\n    const doRecursive = options.recursive;\n\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (occupiedEntry && occupiedEntry.type === 'directory')\n      throw Error('The supplied path is a directory.');\n\n    const encoding = options.encoding;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: doRecursive,\n        });\n      }\n    }\n    const now = Date.now();\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: now,\n      mtime: now,\n      content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data,\n    };\n    await this.dbRequest('put', [pathObj]);\n    return {\n      uri: pathObj.path,\n    };\n  }\n\n  /**\n   * Append to a file on disk in the specified location on device\n   * @param options options for the file append\n   * @return a promise that resolves with the file write result\n   */\n  async appendFile(options: AppendFileOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n    let data = options.data;\n    // const encoding = options.encoding;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const now = Date.now();\n    let ctime = now;\n\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (occupiedEntry && occupiedEntry.type === 'directory')\n      throw Error('The supplied path is a directory.');\n\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: true,\n        });\n      }\n    }\n\n    if (occupiedEntry !== undefined) {\n      data = occupiedEntry.content + data;\n      ctime = occupiedEntry.ctime;\n    }\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: ctime,\n      mtime: now,\n      content: data,\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n\n  /**\n   * Delete a file from disk\n   * @param options options for the file delete\n   * @return a promise that resolves with the deleted file data result\n   */\n  async deleteFile(options: DeleteFileOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) throw Error('File does not exist.');\n    const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [\n      IDBKeyRange.only(path),\n    ]);\n    if (entries.length !== 0) throw Error('Folder is not empty.');\n\n    await this.dbRequest('delete', [path]);\n  }\n\n  /**\n   * Create a directory.\n   * @param options options for the mkdir\n   * @return a promise that resolves with the mkdir result\n   */\n  async mkdir(options: MkdirOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n    const doRecursive = options.recursive;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const depth = (path.match(/\\//g) || []).length;\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (depth === 1) throw Error('Cannot create Root directory');\n    if (occupiedEntry !== undefined)\n      throw Error('Current directory does already exist.');\n    if (!doRecursive && depth !== 2 && parentEntry === undefined)\n      throw Error('Parent directory must exist');\n\n    if (doRecursive && depth !== 2 && parentEntry === undefined) {\n      const parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n      await this.mkdir({\n        path: parentArgPath,\n        directory: options.directory,\n        recursive: doRecursive,\n      });\n    }\n    const now = Date.now();\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'directory',\n      size: 0,\n      ctime: now,\n      mtime: now,\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n\n  /**\n   * Remove a directory\n   * @param options the options for the directory remove\n   */\n  async rmdir(options: RmdirOptions): Promise<void> {\n    const { path, directory, recursive } = options;\n    const fullPath: string = this.getPath(directory, path);\n\n    const entry = (await this.dbRequest('get', [fullPath])) as EntryObj;\n\n    if (entry === undefined) throw Error('Folder does not exist.');\n\n    if (entry.type !== 'directory')\n      throw Error('Requested path is not a directory');\n\n    const readDirResult = await this.readdir({ path, directory });\n\n    if (readDirResult.files.length !== 0 && !recursive)\n      throw Error('Folder is not empty');\n\n    for (const entry of readDirResult.files) {\n      const entryPath = `${path}/${entry}`;\n      const entryObj = await this.stat({ path: entryPath, directory });\n      if (entryObj.type === 'file') {\n        await this.deleteFile({ path: entryPath, directory });\n      } else {\n        await this.rmdir({ path: entryPath, directory, recursive });\n      }\n    }\n\n    await this.dbRequest('delete', [fullPath]);\n  }\n\n  /**\n   * Return a list of files from the directory (not recursive)\n   * @param options the options for the readdir operation\n   * @return a promise that resolves with the readdir directory listing result\n   */\n  async readdir(options: ReaddirOptions): Promise<ReaddirResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (options.path !== '' && entry === undefined)\n      throw Error('Folder does not exist.');\n\n    const entries: string[] = await this.dbIndexRequest(\n      'by_folder',\n      'getAllKeys',\n      [IDBKeyRange.only(path)],\n    );\n    const names = entries.map(e => {\n      return e.substring(path.length + 1);\n    });\n    return { files: names };\n  }\n\n  /**\n   * Return full File URI for a path and directory\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async getUri(options: GetUriOptions): Promise<GetUriResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    let entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) {\n      entry = (await this.dbRequest('get', [path + '/'])) as EntryObj;\n    }\n    return {\n      uri: entry?.path || path,\n    };\n  }\n\n  /**\n   * Return data about a file\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async stat(options: StatOptions): Promise<StatResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    let entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) {\n      entry = (await this.dbRequest('get', [path + '/'])) as EntryObj;\n    }\n    if (entry === undefined) throw Error('Entry does not exist.');\n\n    return {\n      type: entry.type,\n      size: entry.size,\n      ctime: entry.ctime,\n      mtime: entry.mtime,\n      uri: entry.path,\n    };\n  }\n\n  /**\n   * Rename a file or directory\n   * @param options the options for the rename operation\n   * @return a promise that resolves with the rename result\n   */\n  async rename(options: RenameOptions): Promise<void> {\n    return this._copy(options, true);\n  }\n\n  /**\n   * Copy a file or directory\n   * @param options the options for the copy operation\n   * @return a promise that resolves with the copy result\n   */\n  async copy(options: CopyOptions): Promise<void> {\n    return this._copy(options, false);\n  }\n\n  async requestPermissions(): Promise<PermissionStatus> {\n    return { publicStorage: 'granted' };\n  }\n\n  async checkPermissions(): Promise<PermissionStatus> {\n    return { publicStorage: 'granted' };\n  }\n\n  /**\n   * Function that can perform a copy or a rename\n   * @param options the options for the rename operation\n   * @param doRename whether to perform a rename or copy operation\n   * @return a promise that resolves with the result\n   */\n  private async _copy(options: CopyOptions, doRename = false): Promise<void> {\n    let { toDirectory } = options;\n    const { to, from, directory: fromDirectory } = options;\n\n    if (!to || !from) {\n      throw Error('Both to and from must be provided');\n    }\n\n    // If no \"to\" directory is provided, use the \"from\" directory\n    if (!toDirectory) {\n      toDirectory = fromDirectory;\n    }\n\n    const fromPath = this.getPath(fromDirectory, from);\n    const toPath = this.getPath(toDirectory, to);\n\n    // Test that the \"to\" and \"from\" locations are different\n    if (fromPath === toPath) {\n      return;\n    }\n\n    if (isPathParent(fromPath, toPath)) {\n      throw Error('To path cannot contain the from path');\n    }\n\n    // Check the state of the \"to\" location\n    let toObj;\n    try {\n      toObj = await this.stat({\n        path: to,\n        directory: toDirectory,\n      });\n    } catch (e) {\n      // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n      const toPathComponents = to.split('/');\n      toPathComponents.pop();\n      const toPath = toPathComponents.join('/');\n\n      // Check the containing directory of the \"to\" location exists\n      if (toPathComponents.length > 0) {\n        const toParentDirectory = await this.stat({\n          path: toPath,\n          directory: toDirectory,\n        });\n\n        if (toParentDirectory.type !== 'directory') {\n          throw new Error('Parent directory of the to path is a file');\n        }\n      }\n    }\n\n    // Cannot overwrite a directory\n    if (toObj && toObj.type === 'directory') {\n      throw new Error('Cannot overwrite a directory with a file');\n    }\n\n    // Ensure the \"from\" object exists\n    const fromObj = await this.stat({\n      path: from,\n      directory: fromDirectory,\n    });\n\n    // Set the mtime/ctime of the supplied path\n    const updateTime = async (path: string, ctime: number, mtime: number) => {\n      const fullPath: string = this.getPath(toDirectory, path);\n      const entry = (await this.dbRequest('get', [fullPath])) as EntryObj;\n      entry.ctime = ctime;\n      entry.mtime = mtime;\n      await this.dbRequest('put', [entry]);\n    };\n\n    const ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n\n    switch (fromObj.type) {\n      // The \"from\" object is a file\n      case 'file': {\n        // Read the file\n        const file = await this.readFile({\n          path: from,\n          directory: fromDirectory,\n        });\n\n        // Optionally remove the file\n        if (doRename) {\n          await this.deleteFile({\n            path: from,\n            directory: fromDirectory,\n          });\n        }\n\n        // Write the file to the new location\n        await this.writeFile({\n          path: to,\n          directory: toDirectory,\n          data: file.data,\n        });\n\n        // Copy the mtime/ctime of a renamed file\n        if (doRename) {\n          await updateTime(to, ctime, fromObj.mtime);\n        }\n\n        // Resolve promise\n        return;\n      }\n      case 'directory': {\n        if (toObj) {\n          throw Error('Cannot move a directory over an existing object');\n        }\n\n        try {\n          // Create the to directory\n          await this.mkdir({\n            path: to,\n            directory: toDirectory,\n            recursive: false,\n          });\n\n          // Copy the mtime/ctime of a renamed directory\n          if (doRename) {\n            await updateTime(to, ctime, fromObj.mtime);\n          }\n        } catch (e) {\n          // ignore\n        }\n\n        // Iterate over the contents of the from location\n        const contents = (\n          await this.readdir({\n            path: from,\n            directory: fromDirectory,\n          })\n        ).files;\n\n        for (const filename of contents) {\n          // Move item from the from directory to the to directory\n          await this._copy(\n            {\n              from: `${from}/${filename}`,\n              to: `${to}/${filename}`,\n              directory: fromDirectory,\n              toDirectory,\n            },\n            doRename,\n          );\n        }\n\n        // Optionally remove the original from directory\n        if (doRename) {\n          await this.rmdir({\n            path: from,\n            directory: fromDirectory,\n          });\n        }\n      }\n    }\n  }\n}\n\ninterface EntryObj {\n  path: string;\n  folder: string;\n  type: string;\n  size: number;\n  ctime: number;\n  mtime: number;\n  uri?: string;\n  content?: string;\n}\n"]},"metadata":{},"sourceType":"module"}