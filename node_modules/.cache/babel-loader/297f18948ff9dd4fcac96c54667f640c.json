{"ast":null,"code":"import { WebPlugin } from '@capacitor/core';\n\nfunction resolve(path) {\n  const posix = path.split('/').filter(item => item !== '.');\n  const newPosix = [];\n  posix.forEach(item => {\n    if (item === '..' && newPosix.length > 0 && newPosix[newPosix.length - 1] !== '..') {\n      newPosix.pop();\n    } else {\n      newPosix.push(item);\n    }\n  });\n  return newPosix.join('/');\n}\n\nfunction isPathParent(parent, children) {\n  parent = resolve(parent);\n  children = resolve(children);\n  const pathsA = parent.split('/');\n  const pathsB = children.split('/');\n  return parent !== children && pathsA.every((value, index) => value === pathsB[index]);\n}\n\nexport class FilesystemWeb extends WebPlugin {\n  constructor() {\n    super(...arguments);\n    this.DB_VERSION = 1;\n    this.DB_NAME = 'Disc';\n    this._writeCmds = ['add', 'put', 'delete'];\n  }\n\n  async initDb() {\n    if (this._db !== undefined) {\n      return this._db;\n    }\n\n    if (!('indexedDB' in window)) {\n      throw this.unavailable(\"This browser doesn't support IndexedDB\");\n    }\n\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n      request.onupgradeneeded = FilesystemWeb.doUpgrade;\n\n      request.onsuccess = () => {\n        this._db = request.result;\n        resolve(request.result);\n      };\n\n      request.onerror = () => reject(request.error);\n\n      request.onblocked = () => {\n        console.warn('db blocked');\n      };\n    });\n  }\n\n  static doUpgrade(event) {\n    const eventTarget = event.target;\n    const db = eventTarget.result;\n\n    switch (event.oldVersion) {\n      case 0:\n      case 1:\n      default:\n        {\n          if (db.objectStoreNames.contains('FileStorage')) {\n            db.deleteObjectStore('FileStorage');\n          }\n\n          const store = db.createObjectStore('FileStorage', {\n            keyPath: 'path'\n          });\n          store.createIndex('by_folder', 'folder');\n        }\n    }\n  }\n\n  async dbRequest(cmd, args) {\n    const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then(conn => {\n      return new Promise((resolve, reject) => {\n        const tx = conn.transaction(['FileStorage'], readFlag);\n        const store = tx.objectStore('FileStorage');\n        const req = store[cmd](...args);\n\n        req.onsuccess = () => resolve(req.result);\n\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  async dbIndexRequest(indexName, cmd, args) {\n    const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then(conn => {\n      return new Promise((resolve, reject) => {\n        const tx = conn.transaction(['FileStorage'], readFlag);\n        const store = tx.objectStore('FileStorage');\n        const index = store.index(indexName);\n        const req = index[cmd](...args);\n\n        req.onsuccess = () => resolve(req.result);\n\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  getPath(directory, uriPath) {\n    const cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n    let fsPath = '';\n    if (directory !== undefined) fsPath += '/' + directory;\n    if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n    return fsPath;\n  }\n\n  async clear() {\n    const conn = await this.initDb();\n    const tx = conn.transaction(['FileStorage'], 'readwrite');\n    const store = tx.objectStore('FileStorage');\n    store.clear();\n  }\n  /**\n   * Read a file from disk\n   * @param options options for the file read\n   * @return a promise that resolves with the read file data result\n   */\n\n\n  async readFile(options) {\n    const path = this.getPath(options.directory, options.path); // const encoding = options.encoding;\n\n    const entry = await this.dbRequest('get', [path]);\n    if (entry === undefined) throw Error('File does not exist.');\n    return {\n      data: entry.content ? entry.content : ''\n    };\n  }\n  /**\n   * Write a file to disk in the specified location on device\n   * @param options options for the file write\n   * @return a promise that resolves with the file write result\n   */\n\n\n  async writeFile(options) {\n    const path = this.getPath(options.directory, options.path);\n    const data = options.data;\n    const doRecursive = options.recursive;\n    const occupiedEntry = await this.dbRequest('get', [path]);\n    if (occupiedEntry && occupiedEntry.type === 'directory') throw Error('The supplied path is a directory.');\n    const encoding = options.encoding;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n    const parentEntry = await this.dbRequest('get', [parentPath]);\n\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: doRecursive\n        });\n      }\n    }\n\n    const now = Date.now();\n    const pathObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: now,\n      mtime: now,\n      content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data\n    };\n    await this.dbRequest('put', [pathObj]);\n    return {\n      uri: pathObj.path\n    };\n  }\n  /**\n   * Append to a file on disk in the specified location on device\n   * @param options options for the file append\n   * @return a promise that resolves with the file write result\n   */\n\n\n  async appendFile(options) {\n    const path = this.getPath(options.directory, options.path);\n    let data = options.data; // const encoding = options.encoding;\n\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n    const now = Date.now();\n    let ctime = now;\n    const occupiedEntry = await this.dbRequest('get', [path]);\n    if (occupiedEntry && occupiedEntry.type === 'directory') throw Error('The supplied path is a directory.');\n    const parentEntry = await this.dbRequest('get', [parentPath]);\n\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: true\n        });\n      }\n    }\n\n    if (occupiedEntry !== undefined) {\n      data = occupiedEntry.content + data;\n      ctime = occupiedEntry.ctime;\n    }\n\n    const pathObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: ctime,\n      mtime: now,\n      content: data\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n  /**\n   * Delete a file from disk\n   * @param options options for the file delete\n   * @return a promise that resolves with the deleted file data result\n   */\n\n\n  async deleteFile(options) {\n    const path = this.getPath(options.directory, options.path);\n    const entry = await this.dbRequest('get', [path]);\n    if (entry === undefined) throw Error('File does not exist.');\n    const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n    if (entries.length !== 0) throw Error('Folder is not empty.');\n    await this.dbRequest('delete', [path]);\n  }\n  /**\n   * Create a directory.\n   * @param options options for the mkdir\n   * @return a promise that resolves with the mkdir result\n   */\n\n\n  async mkdir(options) {\n    const path = this.getPath(options.directory, options.path);\n    const doRecursive = options.recursive;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n    const depth = (path.match(/\\//g) || []).length;\n    const parentEntry = await this.dbRequest('get', [parentPath]);\n    const occupiedEntry = await this.dbRequest('get', [path]);\n    if (depth === 1) throw Error('Cannot create Root directory');\n    if (occupiedEntry !== undefined) throw Error('Current directory does already exist.');\n    if (!doRecursive && depth !== 2 && parentEntry === undefined) throw Error('Parent directory must exist');\n\n    if (doRecursive && depth !== 2 && parentEntry === undefined) {\n      const parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n      await this.mkdir({\n        path: parentArgPath,\n        directory: options.directory,\n        recursive: doRecursive\n      });\n    }\n\n    const now = Date.now();\n    const pathObj = {\n      path: path,\n      folder: parentPath,\n      type: 'directory',\n      size: 0,\n      ctime: now,\n      mtime: now\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n  /**\n   * Remove a directory\n   * @param options the options for the directory remove\n   */\n\n\n  async rmdir(options) {\n    const {\n      path,\n      directory,\n      recursive\n    } = options;\n    const fullPath = this.getPath(directory, path);\n    const entry = await this.dbRequest('get', [fullPath]);\n    if (entry === undefined) throw Error('Folder does not exist.');\n    if (entry.type !== 'directory') throw Error('Requested path is not a directory');\n    const readDirResult = await this.readdir({\n      path,\n      directory\n    });\n    if (readDirResult.files.length !== 0 && !recursive) throw Error('Folder is not empty');\n\n    for (const entry of readDirResult.files) {\n      const entryPath = `${path}/${entry}`;\n      const entryObj = await this.stat({\n        path: entryPath,\n        directory\n      });\n\n      if (entryObj.type === 'file') {\n        await this.deleteFile({\n          path: entryPath,\n          directory\n        });\n      } else {\n        await this.rmdir({\n          path: entryPath,\n          directory,\n          recursive\n        });\n      }\n    }\n\n    await this.dbRequest('delete', [fullPath]);\n  }\n  /**\n   * Return a list of files from the directory (not recursive)\n   * @param options the options for the readdir operation\n   * @return a promise that resolves with the readdir directory listing result\n   */\n\n\n  async readdir(options) {\n    const path = this.getPath(options.directory, options.path);\n    const entry = await this.dbRequest('get', [path]);\n    if (options.path !== '' && entry === undefined) throw Error('Folder does not exist.');\n    const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n    const names = entries.map(e => {\n      return e.substring(path.length + 1);\n    });\n    return {\n      files: names\n    };\n  }\n  /**\n   * Return full File URI for a path and directory\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n\n\n  async getUri(options) {\n    const path = this.getPath(options.directory, options.path);\n    let entry = await this.dbRequest('get', [path]);\n\n    if (entry === undefined) {\n      entry = await this.dbRequest('get', [path + '/']);\n    }\n\n    return {\n      uri: (entry === null || entry === void 0 ? void 0 : entry.path) || path\n    };\n  }\n  /**\n   * Return data about a file\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n\n\n  async stat(options) {\n    const path = this.getPath(options.directory, options.path);\n    let entry = await this.dbRequest('get', [path]);\n\n    if (entry === undefined) {\n      entry = await this.dbRequest('get', [path + '/']);\n    }\n\n    if (entry === undefined) throw Error('Entry does not exist.');\n    return {\n      type: entry.type,\n      size: entry.size,\n      ctime: entry.ctime,\n      mtime: entry.mtime,\n      uri: entry.path\n    };\n  }\n  /**\n   * Rename a file or directory\n   * @param options the options for the rename operation\n   * @return a promise that resolves with the rename result\n   */\n\n\n  async rename(options) {\n    return this._copy(options, true);\n  }\n  /**\n   * Copy a file or directory\n   * @param options the options for the copy operation\n   * @return a promise that resolves with the copy result\n   */\n\n\n  async copy(options) {\n    return this._copy(options, false);\n  }\n\n  async requestPermissions() {\n    return {\n      publicStorage: 'granted'\n    };\n  }\n\n  async checkPermissions() {\n    return {\n      publicStorage: 'granted'\n    };\n  }\n  /**\n   * Function that can perform a copy or a rename\n   * @param options the options for the rename operation\n   * @param doRename whether to perform a rename or copy operation\n   * @return a promise that resolves with the result\n   */\n\n\n  async _copy(options) {\n    let doRename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let {\n      toDirectory\n    } = options;\n    const {\n      to,\n      from,\n      directory: fromDirectory\n    } = options;\n\n    if (!to || !from) {\n      throw Error('Both to and from must be provided');\n    } // If no \"to\" directory is provided, use the \"from\" directory\n\n\n    if (!toDirectory) {\n      toDirectory = fromDirectory;\n    }\n\n    const fromPath = this.getPath(fromDirectory, from);\n    const toPath = this.getPath(toDirectory, to); // Test that the \"to\" and \"from\" locations are different\n\n    if (fromPath === toPath) {\n      return;\n    }\n\n    if (isPathParent(fromPath, toPath)) {\n      throw Error('To path cannot contain the from path');\n    } // Check the state of the \"to\" location\n\n\n    let toObj;\n\n    try {\n      toObj = await this.stat({\n        path: to,\n        directory: toDirectory\n      });\n    } catch (e) {\n      // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n      const toPathComponents = to.split('/');\n      toPathComponents.pop();\n      const toPath = toPathComponents.join('/'); // Check the containing directory of the \"to\" location exists\n\n      if (toPathComponents.length > 0) {\n        const toParentDirectory = await this.stat({\n          path: toPath,\n          directory: toDirectory\n        });\n\n        if (toParentDirectory.type !== 'directory') {\n          throw new Error('Parent directory of the to path is a file');\n        }\n      }\n    } // Cannot overwrite a directory\n\n\n    if (toObj && toObj.type === 'directory') {\n      throw new Error('Cannot overwrite a directory with a file');\n    } // Ensure the \"from\" object exists\n\n\n    const fromObj = await this.stat({\n      path: from,\n      directory: fromDirectory\n    }); // Set the mtime/ctime of the supplied path\n\n    const updateTime = async (path, ctime, mtime) => {\n      const fullPath = this.getPath(toDirectory, path);\n      const entry = await this.dbRequest('get', [fullPath]);\n      entry.ctime = ctime;\n      entry.mtime = mtime;\n      await this.dbRequest('put', [entry]);\n    };\n\n    const ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n\n    switch (fromObj.type) {\n      // The \"from\" object is a file\n      case 'file':\n        {\n          // Read the file\n          const file = await this.readFile({\n            path: from,\n            directory: fromDirectory\n          }); // Optionally remove the file\n\n          if (doRename) {\n            await this.deleteFile({\n              path: from,\n              directory: fromDirectory\n            });\n          } // Write the file to the new location\n\n\n          await this.writeFile({\n            path: to,\n            directory: toDirectory,\n            data: file.data\n          }); // Copy the mtime/ctime of a renamed file\n\n          if (doRename) {\n            await updateTime(to, ctime, fromObj.mtime);\n          } // Resolve promise\n\n\n          return;\n        }\n\n      case 'directory':\n        {\n          if (toObj) {\n            throw Error('Cannot move a directory over an existing object');\n          }\n\n          try {\n            // Create the to directory\n            await this.mkdir({\n              path: to,\n              directory: toDirectory,\n              recursive: false\n            }); // Copy the mtime/ctime of a renamed directory\n\n            if (doRename) {\n              await updateTime(to, ctime, fromObj.mtime);\n            }\n          } catch (e) {// ignore\n          } // Iterate over the contents of the from location\n\n\n          const contents = (await this.readdir({\n            path: from,\n            directory: fromDirectory\n          })).files;\n\n          for (const filename of contents) {\n            // Move item from the from directory to the to directory\n            await this._copy({\n              from: `${from}/${filename}`,\n              to: `${to}/${filename}`,\n              directory: fromDirectory,\n              toDirectory\n            }, doRename);\n          } // Optionally remove the original from directory\n\n\n          if (doRename) {\n            await this.rmdir({\n              path: from,\n              directory: fromDirectory\n            });\n          }\n        }\n    }\n  }\n\n}\nFilesystemWeb._debug = true;","map":{"version":3,"mappings":"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","names":["WebPlugin","resolve","path","posix","split","filter","item","newPosix","forEach","length","pop","push","join","isPathParent","parent","children","pathsA","pathsB","every","value","index","FilesystemWeb","constructor","initDb","_db","undefined","window","unavailable","Promise","reject","request","indexedDB","open","DB_NAME","DB_VERSION","onupgradeneeded","doUpgrade","onsuccess","result","onerror","error","onblocked","console","warn","event","eventTarget","target","db","oldVersion","objectStoreNames","contains","deleteObjectStore","store","createObjectStore","keyPath","createIndex","dbRequest","cmd","args","readFlag","_writeCmds","indexOf","then","conn","tx","transaction","objectStore","req","dbIndexRequest","indexName","getPath","directory","uriPath","cleanedUriPath","replace","fsPath","clear","readFile","options","entry","Error","data","content","writeFile","doRecursive","recursive","occupiedEntry","type","encoding","parentPath","substr","lastIndexOf","parentEntry","subDirIndex","parentArgPath","mkdir","now","Date","pathObj","folder","size","ctime","mtime","uri","appendFile","deleteFile","entries","IDBKeyRange","only","depth","match","rmdir","fullPath","readDirResult","readdir","files","entryPath","entryObj","stat","names","map","e","substring","getUri","rename","_copy","copy","requestPermissions","publicStorage","checkPermissions","doRename","toDirectory","to","from","fromDirectory","fromPath","toPath","toObj","toPathComponents","toParentDirectory","fromObj","updateTime","file","contents","filename"],"sources":["/data/data/com.termux/files/home/Ionic/ExploringApp/node_modules/@capacitor/filesystem/src/web.ts"],"sourcesContent":["import { WebPlugin } from '@capacitor/core';\n\nimport type {\n  AppendFileOptions,\n  CopyOptions,\n  DeleteFileOptions,\n  FilesystemPlugin,\n  GetUriOptions,\n  GetUriResult,\n  MkdirOptions,\n  PermissionStatus,\n  ReadFileOptions,\n  ReadFileResult,\n  ReaddirOptions,\n  ReaddirResult,\n  RenameOptions,\n  RmdirOptions,\n  StatOptions,\n  StatResult,\n  WriteFileOptions,\n  WriteFileResult,\n  Directory,\n} from './definitions';\n\nfunction resolve(path: string): string {\n  const posix = path.split('/').filter(item => item !== '.');\n  const newPosix: string[] = [];\n\n  posix.forEach(item => {\n    if (\n      item === '..' &&\n      newPosix.length > 0 &&\n      newPosix[newPosix.length - 1] !== '..'\n    ) {\n      newPosix.pop();\n    } else {\n      newPosix.push(item);\n    }\n  });\n\n  return newPosix.join('/');\n}\nfunction isPathParent(parent: string, children: string): boolean {\n  parent = resolve(parent);\n  children = resolve(children);\n  const pathsA = parent.split('/');\n  const pathsB = children.split('/');\n\n  return (\n    parent !== children &&\n    pathsA.every((value, index) => value === pathsB[index])\n  );\n}\n\nexport class FilesystemWeb extends WebPlugin implements FilesystemPlugin {\n  DB_VERSION = 1;\n  DB_NAME = 'Disc';\n\n  private _writeCmds: string[] = ['add', 'put', 'delete'];\n  private _db?: IDBDatabase;\n  static _debug = true;\n  async initDb(): Promise<IDBDatabase> {\n    if (this._db !== undefined) {\n      return this._db;\n    }\n    if (!('indexedDB' in window)) {\n      throw this.unavailable(\"This browser doesn't support IndexedDB\");\n    }\n\n    return new Promise<IDBDatabase>((resolve, reject) => {\n      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n      request.onupgradeneeded = FilesystemWeb.doUpgrade;\n      request.onsuccess = () => {\n        this._db = request.result;\n        resolve(request.result);\n      };\n      request.onerror = () => reject(request.error);\n      request.onblocked = () => {\n        console.warn('db blocked');\n      };\n    });\n  }\n\n  static doUpgrade(event: IDBVersionChangeEvent): void {\n    const eventTarget = event.target as IDBOpenDBRequest;\n    const db = eventTarget.result;\n    switch (event.oldVersion) {\n      case 0:\n      case 1:\n      default: {\n        if (db.objectStoreNames.contains('FileStorage')) {\n          db.deleteObjectStore('FileStorage');\n        }\n        const store = db.createObjectStore('FileStorage', { keyPath: 'path' });\n        store.createIndex('by_folder', 'folder');\n      }\n    }\n  }\n\n  async dbRequest(cmd: string, args: any[]): Promise<any> {\n    const readFlag =\n      this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then((conn: IDBDatabase) => {\n      return new Promise<IDBObjectStore>((resolve, reject) => {\n        const tx: IDBTransaction = conn.transaction(['FileStorage'], readFlag);\n        const store: any = tx.objectStore('FileStorage');\n        const req = store[cmd](...args);\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  async dbIndexRequest(\n    indexName: string,\n    cmd: string,\n    args: [any],\n  ): Promise<any> {\n    const readFlag =\n      this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then((conn: IDBDatabase) => {\n      return new Promise<IDBObjectStore>((resolve, reject) => {\n        const tx: IDBTransaction = conn.transaction(['FileStorage'], readFlag);\n        const store: IDBObjectStore = tx.objectStore('FileStorage');\n        const index: any = store.index(indexName);\n        const req = index[cmd](...args) as any;\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  private getPath(\n    directory: Directory | undefined,\n    uriPath: string | undefined,\n  ): string {\n    const cleanedUriPath =\n      uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n    let fsPath = '';\n    if (directory !== undefined) fsPath += '/' + directory;\n    if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n    return fsPath;\n  }\n\n  async clear(): Promise<void> {\n    const conn: IDBDatabase = await this.initDb();\n    const tx: IDBTransaction = conn.transaction(['FileStorage'], 'readwrite');\n    const store: IDBObjectStore = tx.objectStore('FileStorage');\n    store.clear();\n  }\n\n  /**\n   * Read a file from disk\n   * @param options options for the file read\n   * @return a promise that resolves with the read file data result\n   */\n  async readFile(options: ReadFileOptions): Promise<ReadFileResult> {\n    const path: string = this.getPath(options.directory, options.path);\n    // const encoding = options.encoding;\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) throw Error('File does not exist.');\n    return { data: entry.content ? entry.content : '' };\n  }\n\n  /**\n   * Write a file to disk in the specified location on device\n   * @param options options for the file write\n   * @return a promise that resolves with the file write result\n   */\n  async writeFile(options: WriteFileOptions): Promise<WriteFileResult> {\n    const path: string = this.getPath(options.directory, options.path);\n    const data = options.data;\n    const doRecursive = options.recursive;\n\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (occupiedEntry && occupiedEntry.type === 'directory')\n      throw Error('The supplied path is a directory.');\n\n    const encoding = options.encoding;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: doRecursive,\n        });\n      }\n    }\n    const now = Date.now();\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: now,\n      mtime: now,\n      content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data,\n    };\n    await this.dbRequest('put', [pathObj]);\n    return {\n      uri: pathObj.path,\n    };\n  }\n\n  /**\n   * Append to a file on disk in the specified location on device\n   * @param options options for the file append\n   * @return a promise that resolves with the file write result\n   */\n  async appendFile(options: AppendFileOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n    let data = options.data;\n    // const encoding = options.encoding;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const now = Date.now();\n    let ctime = now;\n\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (occupiedEntry && occupiedEntry.type === 'directory')\n      throw Error('The supplied path is a directory.');\n\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: true,\n        });\n      }\n    }\n\n    if (occupiedEntry !== undefined) {\n      data = occupiedEntry.content + data;\n      ctime = occupiedEntry.ctime;\n    }\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: ctime,\n      mtime: now,\n      content: data,\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n\n  /**\n   * Delete a file from disk\n   * @param options options for the file delete\n   * @return a promise that resolves with the deleted file data result\n   */\n  async deleteFile(options: DeleteFileOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) throw Error('File does not exist.');\n    const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [\n      IDBKeyRange.only(path),\n    ]);\n    if (entries.length !== 0) throw Error('Folder is not empty.');\n\n    await this.dbRequest('delete', [path]);\n  }\n\n  /**\n   * Create a directory.\n   * @param options options for the mkdir\n   * @return a promise that resolves with the mkdir result\n   */\n  async mkdir(options: MkdirOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n    const doRecursive = options.recursive;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const depth = (path.match(/\\//g) || []).length;\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (depth === 1) throw Error('Cannot create Root directory');\n    if (occupiedEntry !== undefined)\n      throw Error('Current directory does already exist.');\n    if (!doRecursive && depth !== 2 && parentEntry === undefined)\n      throw Error('Parent directory must exist');\n\n    if (doRecursive && depth !== 2 && parentEntry === undefined) {\n      const parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n      await this.mkdir({\n        path: parentArgPath,\n        directory: options.directory,\n        recursive: doRecursive,\n      });\n    }\n    const now = Date.now();\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'directory',\n      size: 0,\n      ctime: now,\n      mtime: now,\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n\n  /**\n   * Remove a directory\n   * @param options the options for the directory remove\n   */\n  async rmdir(options: RmdirOptions): Promise<void> {\n    const { path, directory, recursive } = options;\n    const fullPath: string = this.getPath(directory, path);\n\n    const entry = (await this.dbRequest('get', [fullPath])) as EntryObj;\n\n    if (entry === undefined) throw Error('Folder does not exist.');\n\n    if (entry.type !== 'directory')\n      throw Error('Requested path is not a directory');\n\n    const readDirResult = await this.readdir({ path, directory });\n\n    if (readDirResult.files.length !== 0 && !recursive)\n      throw Error('Folder is not empty');\n\n    for (const entry of readDirResult.files) {\n      const entryPath = `${path}/${entry}`;\n      const entryObj = await this.stat({ path: entryPath, directory });\n      if (entryObj.type === 'file') {\n        await this.deleteFile({ path: entryPath, directory });\n      } else {\n        await this.rmdir({ path: entryPath, directory, recursive });\n      }\n    }\n\n    await this.dbRequest('delete', [fullPath]);\n  }\n\n  /**\n   * Return a list of files from the directory (not recursive)\n   * @param options the options for the readdir operation\n   * @return a promise that resolves with the readdir directory listing result\n   */\n  async readdir(options: ReaddirOptions): Promise<ReaddirResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (options.path !== '' && entry === undefined)\n      throw Error('Folder does not exist.');\n\n    const entries: string[] = await this.dbIndexRequest(\n      'by_folder',\n      'getAllKeys',\n      [IDBKeyRange.only(path)],\n    );\n    const names = entries.map(e => {\n      return e.substring(path.length + 1);\n    });\n    return { files: names };\n  }\n\n  /**\n   * Return full File URI for a path and directory\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async getUri(options: GetUriOptions): Promise<GetUriResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    let entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) {\n      entry = (await this.dbRequest('get', [path + '/'])) as EntryObj;\n    }\n    return {\n      uri: entry?.path || path,\n    };\n  }\n\n  /**\n   * Return data about a file\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async stat(options: StatOptions): Promise<StatResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    let entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) {\n      entry = (await this.dbRequest('get', [path + '/'])) as EntryObj;\n    }\n    if (entry === undefined) throw Error('Entry does not exist.');\n\n    return {\n      type: entry.type,\n      size: entry.size,\n      ctime: entry.ctime,\n      mtime: entry.mtime,\n      uri: entry.path,\n    };\n  }\n\n  /**\n   * Rename a file or directory\n   * @param options the options for the rename operation\n   * @return a promise that resolves with the rename result\n   */\n  async rename(options: RenameOptions): Promise<void> {\n    return this._copy(options, true);\n  }\n\n  /**\n   * Copy a file or directory\n   * @param options the options for the copy operation\n   * @return a promise that resolves with the copy result\n   */\n  async copy(options: CopyOptions): Promise<void> {\n    return this._copy(options, false);\n  }\n\n  async requestPermissions(): Promise<PermissionStatus> {\n    return { publicStorage: 'granted' };\n  }\n\n  async checkPermissions(): Promise<PermissionStatus> {\n    return { publicStorage: 'granted' };\n  }\n\n  /**\n   * Function that can perform a copy or a rename\n   * @param options the options for the rename operation\n   * @param doRename whether to perform a rename or copy operation\n   * @return a promise that resolves with the result\n   */\n  private async _copy(options: CopyOptions, doRename = false): Promise<void> {\n    let { toDirectory } = options;\n    const { to, from, directory: fromDirectory } = options;\n\n    if (!to || !from) {\n      throw Error('Both to and from must be provided');\n    }\n\n    // If no \"to\" directory is provided, use the \"from\" directory\n    if (!toDirectory) {\n      toDirectory = fromDirectory;\n    }\n\n    const fromPath = this.getPath(fromDirectory, from);\n    const toPath = this.getPath(toDirectory, to);\n\n    // Test that the \"to\" and \"from\" locations are different\n    if (fromPath === toPath) {\n      return;\n    }\n\n    if (isPathParent(fromPath, toPath)) {\n      throw Error('To path cannot contain the from path');\n    }\n\n    // Check the state of the \"to\" location\n    let toObj;\n    try {\n      toObj = await this.stat({\n        path: to,\n        directory: toDirectory,\n      });\n    } catch (e) {\n      // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n      const toPathComponents = to.split('/');\n      toPathComponents.pop();\n      const toPath = toPathComponents.join('/');\n\n      // Check the containing directory of the \"to\" location exists\n      if (toPathComponents.length > 0) {\n        const toParentDirectory = await this.stat({\n          path: toPath,\n          directory: toDirectory,\n        });\n\n        if (toParentDirectory.type !== 'directory') {\n          throw new Error('Parent directory of the to path is a file');\n        }\n      }\n    }\n\n    // Cannot overwrite a directory\n    if (toObj && toObj.type === 'directory') {\n      throw new Error('Cannot overwrite a directory with a file');\n    }\n\n    // Ensure the \"from\" object exists\n    const fromObj = await this.stat({\n      path: from,\n      directory: fromDirectory,\n    });\n\n    // Set the mtime/ctime of the supplied path\n    const updateTime = async (path: string, ctime: number, mtime: number) => {\n      const fullPath: string = this.getPath(toDirectory, path);\n      const entry = (await this.dbRequest('get', [fullPath])) as EntryObj;\n      entry.ctime = ctime;\n      entry.mtime = mtime;\n      await this.dbRequest('put', [entry]);\n    };\n\n    const ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n\n    switch (fromObj.type) {\n      // The \"from\" object is a file\n      case 'file': {\n        // Read the file\n        const file = await this.readFile({\n          path: from,\n          directory: fromDirectory,\n        });\n\n        // Optionally remove the file\n        if (doRename) {\n          await this.deleteFile({\n            path: from,\n            directory: fromDirectory,\n          });\n        }\n\n        // Write the file to the new location\n        await this.writeFile({\n          path: to,\n          directory: toDirectory,\n          data: file.data,\n        });\n\n        // Copy the mtime/ctime of a renamed file\n        if (doRename) {\n          await updateTime(to, ctime, fromObj.mtime);\n        }\n\n        // Resolve promise\n        return;\n      }\n      case 'directory': {\n        if (toObj) {\n          throw Error('Cannot move a directory over an existing object');\n        }\n\n        try {\n          // Create the to directory\n          await this.mkdir({\n            path: to,\n            directory: toDirectory,\n            recursive: false,\n          });\n\n          // Copy the mtime/ctime of a renamed directory\n          if (doRename) {\n            await updateTime(to, ctime, fromObj.mtime);\n          }\n        } catch (e) {\n          // ignore\n        }\n\n        // Iterate over the contents of the from location\n        const contents = (\n          await this.readdir({\n            path: from,\n            directory: fromDirectory,\n          })\n        ).files;\n\n        for (const filename of contents) {\n          // Move item from the from directory to the to directory\n          await this._copy(\n            {\n              from: `${from}/${filename}`,\n              to: `${to}/${filename}`,\n              directory: fromDirectory,\n              toDirectory,\n            },\n            doRename,\n          );\n        }\n\n        // Optionally remove the original from directory\n        if (doRename) {\n          await this.rmdir({\n            path: from,\n            directory: fromDirectory,\n          });\n        }\n      }\n    }\n  }\n}\n\ninterface EntryObj {\n  path: string;\n  folder: string;\n  type: string;\n  size: number;\n  ctime: number;\n  mtime: number;\n  uri?: string;\n  content?: string;\n}\n"]},"metadata":{},"sourceType":"module"}