{"ast":null,"code":"import { WebPlugin } from '@capacitor/core';\nexport class LocalNotificationsWeb extends WebPlugin {\n  constructor() {\n    super(...arguments);\n    this.pending = [];\n\n    this.hasNotificationSupport = () => {\n      if (!('Notification' in window) || !Notification.requestPermission) {\n        return false;\n      }\n\n      if (Notification.permission !== 'granted') {\n        // don't test for `new Notification` if permission has already been granted\n        // otherwise this sends a real notification on supported browsers\n        try {\n          new Notification('');\n        } catch (e) {\n          if (e.name == 'TypeError') {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    };\n  }\n\n  async createChannel() {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async deleteChannel() {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async listChannels() {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async schedule(options) {\n    if (!this.hasNotificationSupport()) {\n      throw this.unavailable('Notifications not supported in this browser.');\n    }\n\n    for (const notification of options.notifications) {\n      this.sendNotification(notification);\n    }\n\n    return {\n      notifications: options.notifications.map(notification => ({\n        id: notification.id\n      }))\n    };\n  }\n\n  async getPending() {\n    return {\n      notifications: this.pending\n    };\n  }\n\n  async registerActionTypes() {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async cancel(pending) {\n    this.pending = this.pending.filter(notification => !pending.notifications.find(n => n.id === notification.id));\n  }\n\n  async areEnabled() {\n    const {\n      display\n    } = await this.checkPermissions();\n    return {\n      value: display === 'granted'\n    };\n  }\n\n  async requestPermissions() {\n    if (!this.hasNotificationSupport()) {\n      throw this.unavailable('Notifications not supported in this browser.');\n    }\n\n    const display = this.transformNotificationPermission(await Notification.requestPermission());\n    return {\n      display\n    };\n  }\n\n  async checkPermissions() {\n    if (!this.hasNotificationSupport()) {\n      throw this.unavailable('Notifications not supported in this browser.');\n    }\n\n    const display = this.transformNotificationPermission(Notification.permission);\n    return {\n      display\n    };\n  }\n\n  transformNotificationPermission(permission) {\n    switch (permission) {\n      case 'granted':\n        return 'granted';\n\n      case 'denied':\n        return 'denied';\n\n      default:\n        return 'prompt';\n    }\n  }\n\n  sendPending() {\n    var _a;\n\n    const toRemove = [];\n    const now = new Date().getTime();\n\n    for (const notification of this.pending) {\n      if (((_a = notification.schedule) === null || _a === void 0 ? void 0 : _a.at) && notification.schedule.at.getTime() <= now) {\n        this.buildNotification(notification);\n        toRemove.push(notification);\n      }\n    }\n\n    this.pending = this.pending.filter(notification => !toRemove.find(n => n === notification));\n  }\n\n  sendNotification(notification) {\n    var _a;\n\n    if ((_a = notification.schedule) === null || _a === void 0 ? void 0 : _a.at) {\n      const diff = notification.schedule.at.getTime() - new Date().getTime();\n      this.pending.push(notification);\n      setTimeout(() => {\n        this.sendPending();\n      }, diff);\n      return;\n    }\n\n    this.buildNotification(notification);\n  }\n\n  buildNotification(notification) {\n    const localNotification = new Notification(notification.title, {\n      body: notification.body\n    });\n    localNotification.addEventListener('click', this.onClick.bind(this, notification), false);\n    localNotification.addEventListener('show', this.onShow.bind(this, notification), false);\n    return localNotification;\n  }\n\n  onClick(notification) {\n    const data = {\n      actionId: 'tap',\n      notification\n    };\n    this.notifyListeners('localNotificationActionPerformed', data);\n  }\n\n  onShow(notification) {\n    this.notifyListeners('localNotificationReceived', notification);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["WebPlugin","LocalNotificationsWeb","constructor","window","Notification","requestPermission","permission","e","name","createChannel","unimplemented","deleteChannel","listChannels","schedule","options","hasNotificationSupport","unavailable","notification","notifications","sendNotification","map","id","getPending","pending","registerActionTypes","cancel","filter","find","n","areEnabled","display","checkPermissions","value","requestPermissions","transformNotificationPermission","sendPending","toRemove","now","Date","getTime","_a","at","buildNotification","push","diff","setTimeout","localNotification","title","body","addEventListener","onClick","bind","onShow","data","actionId","notifyListeners"],"sources":["/data/data/com.termux/files/home/Ionic/ExploringApp/node_modules/@capacitor/local-notifications/src/web.ts"],"sourcesContent":["import { WebPlugin } from '@capacitor/core';\nimport type { PermissionState } from '@capacitor/core';\n\nimport type {\n  EnabledResult,\n  ListChannelsResult,\n  LocalNotificationSchema,\n  LocalNotificationsPlugin,\n  PendingResult,\n  PermissionStatus,\n  ScheduleOptions,\n  ScheduleResult,\n} from './definitions';\n\nexport class LocalNotificationsWeb\n  extends WebPlugin\n  implements LocalNotificationsPlugin\n{\n  protected pending: LocalNotificationSchema[] = [];\n\n  async createChannel(): Promise<void> {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async deleteChannel(): Promise<void> {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async listChannels(): Promise<ListChannelsResult> {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async schedule(options: ScheduleOptions): Promise<ScheduleResult> {\n    if (!this.hasNotificationSupport()) {\n      throw this.unavailable('Notifications not supported in this browser.');\n    }\n\n    for (const notification of options.notifications) {\n      this.sendNotification(notification);\n    }\n\n    return {\n      notifications: options.notifications.map(notification => ({\n        id: notification.id,\n      })),\n    };\n  }\n\n  async getPending(): Promise<PendingResult> {\n    return {\n      notifications: this.pending,\n    };\n  }\n\n  async registerActionTypes(): Promise<void> {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async cancel(pending: ScheduleResult): Promise<void> {\n    this.pending = this.pending.filter(\n      notification =>\n        !pending.notifications.find(n => n.id === notification.id),\n    );\n  }\n\n  async areEnabled(): Promise<EnabledResult> {\n    const { display } = await this.checkPermissions();\n\n    return {\n      value: display === 'granted',\n    };\n  }\n\n  async requestPermissions(): Promise<PermissionStatus> {\n    if (!this.hasNotificationSupport()) {\n      throw this.unavailable('Notifications not supported in this browser.');\n    }\n\n    const display = this.transformNotificationPermission(\n      await Notification.requestPermission(),\n    );\n\n    return { display };\n  }\n\n  async checkPermissions(): Promise<PermissionStatus> {\n    if (!this.hasNotificationSupport()) {\n      throw this.unavailable('Notifications not supported in this browser.');\n    }\n\n    const display = this.transformNotificationPermission(\n      Notification.permission,\n    );\n\n    return { display };\n  }\n\n  protected hasNotificationSupport = (): boolean => {\n    if (!('Notification' in window) || !Notification.requestPermission) {\n      return false;\n    }\n\n    if (Notification.permission !== 'granted') {\n      // don't test for `new Notification` if permission has already been granted\n      // otherwise this sends a real notification on supported browsers\n      try {\n        new Notification('');\n      } catch (e) {\n        if (e.name == 'TypeError') {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  protected transformNotificationPermission(\n    permission: NotificationPermission,\n  ): PermissionState {\n    switch (permission) {\n      case 'granted':\n        return 'granted';\n      case 'denied':\n        return 'denied';\n      default:\n        return 'prompt';\n    }\n  }\n\n  protected sendPending(): void {\n    const toRemove: LocalNotificationSchema[] = [];\n    const now = new Date().getTime();\n\n    for (const notification of this.pending) {\n      if (\n        notification.schedule?.at &&\n        notification.schedule.at.getTime() <= now\n      ) {\n        this.buildNotification(notification);\n        toRemove.push(notification);\n      }\n    }\n\n    this.pending = this.pending.filter(\n      notification => !toRemove.find(n => n === notification),\n    );\n  }\n\n  protected sendNotification(notification: LocalNotificationSchema): void {\n    if (notification.schedule?.at) {\n      const diff = notification.schedule.at.getTime() - new Date().getTime();\n\n      this.pending.push(notification);\n      setTimeout(() => {\n        this.sendPending();\n      }, diff);\n      return;\n    }\n    this.buildNotification(notification);\n  }\n\n  protected buildNotification(\n    notification: LocalNotificationSchema,\n  ): Notification {\n    const localNotification = new Notification(notification.title, {\n      body: notification.body,\n    });\n    localNotification.addEventListener(\n      'click',\n      this.onClick.bind(this, notification),\n      false,\n    );\n    localNotification.addEventListener(\n      'show',\n      this.onShow.bind(this, notification),\n      false,\n    );\n    return localNotification;\n  }\n\n  protected onClick(notification: LocalNotificationSchema): void {\n    const data = {\n      actionId: 'tap',\n      notification,\n    };\n    this.notifyListeners('localNotificationActionPerformed', data);\n  }\n\n  protected onShow(notification: LocalNotificationSchema): void {\n    this.notifyListeners('localNotificationReceived', notification);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}