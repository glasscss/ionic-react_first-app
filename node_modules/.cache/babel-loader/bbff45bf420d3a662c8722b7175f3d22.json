{"ast":null,"code":"import { fromEvent, Observable } from 'rxjs';\nexport var ERR_CORDOVA_NOT_AVAILABLE = {\n  error: 'cordova_not_available'\n};\nexport var ERR_PLUGIN_NOT_INSTALLED = {\n  error: 'plugin_not_installed'\n};\n/**\n * @param callback\n */\n\nexport function getPromise(callback) {\n  var tryNativePromise = function tryNativePromise() {\n    if (Promise) {\n      return new Promise(function (resolve, reject) {\n        callback(resolve, reject);\n      });\n    } else {\n      console.error('No Promise support or polyfill found. To enable Ionic Native support, please add the es6-promise polyfill before this script, or run with a library like Angular or on a recent browser.');\n    }\n  };\n\n  if (typeof window !== 'undefined' && window.angular) {\n    var doc = window.document;\n    var injector = window.angular.element(doc.querySelector('[ng-app]') || doc.body).injector();\n\n    if (injector) {\n      var $q = injector.get('$q');\n      return $q(function (resolve, reject) {\n        callback(resolve, reject);\n      });\n    }\n\n    console.warn(\"Angular 1 was detected but $q couldn't be retrieved. This is usually when the app is not bootstrapped on the html or body tag. Falling back to native promises which won't trigger an automatic digest when promises resolve.\");\n  }\n\n  return tryNativePromise();\n}\n/**\n * @param pluginObj\n * @param methodName\n * @param args\n * @param opts\n */\n\nexport function wrapPromise(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  var pluginResult, rej;\n  var p = getPromise(function (resolve, reject) {\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return resolve(args);\n      }, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return reject(args);\n      });\n    } else {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject);\n    }\n\n    rej = reject;\n  }); // Angular throws an error on unhandled rejection, but in this case we have already printed\n  // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n  // to error\n\n  if (pluginResult && pluginResult.error) {\n    p.catch(function () {});\n    typeof rej === 'function' && rej(pluginResult.error);\n  }\n\n  return p;\n}\n/**\n * @param pluginObj\n * @param methodName\n * @param args\n * @param opts\n */\n\nfunction wrapOtherPromise(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return getPromise(function (resolve, reject) {\n    var pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts);\n\n    if (pluginResult) {\n      if (pluginResult.error) {\n        reject(pluginResult.error);\n      } else if (pluginResult.then) {\n        pluginResult.then(resolve).catch(reject);\n      }\n    } else {\n      reject({\n        error: 'unexpected_error'\n      });\n    }\n  });\n}\n/**\n * @param pluginObj\n * @param methodName\n * @param args\n * @param opts\n */\n\n\nfunction wrapObservable(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return new Observable(function (observer) {\n    var pluginResult;\n\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return observer.next(args);\n      }, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return observer.error(args);\n      });\n    } else {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n    }\n\n    if (pluginResult && pluginResult.error) {\n      observer.error(pluginResult.error);\n      observer.complete();\n    }\n\n    return function () {\n      try {\n        if (opts.clearFunction) {\n          if (opts.clearWithArgs) {\n            return callCordovaPlugin(pluginObj, opts.clearFunction, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n          }\n\n          return callCordovaPlugin(pluginObj, opts.clearFunction, []);\n        }\n      } catch (e) {\n        console.warn('Unable to clear the previous observable watch for', pluginObj.constructor.getPluginName(), methodName);\n        console.warn(e);\n      }\n    };\n  });\n}\n/**\n * Wrap the event with an observable\n *\n * @private\n * @param event event name\n * @param element The element to attach the event listener to\n * @returns {Observable}\n */\n\n\nfunction wrapEventObservable(event, element) {\n  element = typeof window !== 'undefined' && element ? get(window, element) : element || (typeof window !== 'undefined' ? window : {});\n  return fromEvent(element, event);\n}\n/**\n * @param plugin\n * @param methodName\n * @param pluginName\n */\n\n\nexport function checkAvailability(plugin, methodName, pluginName) {\n  var pluginRef, pluginPackage;\n\n  if (typeof plugin === 'string') {\n    pluginRef = plugin;\n  } else {\n    pluginRef = plugin.constructor.getPluginRef();\n    pluginName = plugin.constructor.getPluginName();\n    pluginPackage = plugin.constructor.getPluginInstallName();\n  }\n\n  var pluginInstance = getPlugin(pluginRef);\n\n  if (!pluginInstance || !!methodName && typeof pluginInstance[methodName] === 'undefined') {\n    if (typeof window === 'undefined' || !window.cordova) {\n      cordovaWarn(pluginName, methodName);\n      return ERR_CORDOVA_NOT_AVAILABLE;\n    }\n\n    pluginWarn(pluginName, pluginPackage, methodName);\n    return ERR_PLUGIN_NOT_INSTALLED;\n  }\n\n  return true;\n}\n/**\n * Checks if _objectInstance exists and has the method/property\n *\n * @param pluginObj\n * @param methodName\n * @private\n */\n\nexport function instanceAvailability(pluginObj, methodName) {\n  return pluginObj._objectInstance && (!methodName || typeof pluginObj._objectInstance[methodName] !== 'undefined');\n}\n/**\n * @param args\n * @param opts\n * @param resolve\n * @param reject\n */\n\nexport function setIndex(args, opts, resolve, reject) {\n  if (opts === void 0) {\n    opts = {};\n  } // ignore resolve and reject in case sync\n\n\n  if (opts.sync) {\n    return args;\n  } // If the plugin method expects myMethod(success, err, options)\n\n\n  if (opts.callbackOrder === 'reverse') {\n    // Get those arguments in the order [resolve, reject, ...restOfArgs]\n    args.unshift(reject);\n    args.unshift(resolve);\n  } else if (opts.callbackStyle === 'node') {\n    args.push(function (err, result) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    });\n  } else if (opts.callbackStyle === 'object' && opts.successName && opts.errorName) {\n    var obj = {};\n    obj[opts.successName] = resolve;\n    obj[opts.errorName] = reject;\n    args.push(obj);\n  } else if (typeof opts.successIndex !== 'undefined' || typeof opts.errorIndex !== 'undefined') {\n    var setSuccessIndex = function setSuccessIndex() {\n      // If we've specified a success/error index\n      if (opts.successIndex > args.length) {\n        args[opts.successIndex] = resolve;\n      } else {\n        args.splice(opts.successIndex, 0, resolve);\n      }\n    };\n\n    var setErrorIndex = function setErrorIndex() {\n      // We don't want that the reject cb gets spliced into the position of an optional argument that has not been\n      // defined and thus causing non expected behavior.\n      if (opts.errorIndex > args.length) {\n        args[opts.errorIndex] = reject; // insert the reject fn at the correct specific index\n      } else {\n        args.splice(opts.errorIndex, 0, reject); // otherwise just splice it into the array\n      }\n    };\n\n    if (opts.successIndex > opts.errorIndex) {\n      setErrorIndex();\n      setSuccessIndex();\n    } else {\n      setSuccessIndex();\n      setErrorIndex();\n    }\n  } else {\n    // Otherwise, let's tack them on to the end of the argument list\n    // which is 90% of cases\n    args.push(resolve);\n    args.push(reject);\n  }\n\n  return args;\n}\n/**\n * @param pluginObj\n * @param methodName\n * @param args\n * @param opts\n * @param resolve\n * @param reject\n */\n\nexport function callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject) {\n  if (opts === void 0) {\n    opts = {};\n  } // Try to figure out where the success/error callbacks need to be bound\n  // to our promise resolve/reject handlers.\n\n\n  args = setIndex(args, opts, resolve, reject);\n  var availabilityCheck = checkAvailability(pluginObj, methodName);\n\n  if (availabilityCheck === true) {\n    var pluginInstance = getPlugin(pluginObj.constructor.getPluginRef()); // eslint-disable-next-line prefer-spread\n\n    return pluginInstance[methodName].apply(pluginInstance, args);\n  } else {\n    return availabilityCheck;\n  }\n}\n/**\n * @param pluginObj\n * @param methodName\n * @param args\n * @param opts\n * @param resolve\n * @param reject\n */\n\nexport function callInstance(pluginObj, methodName, args, opts, resolve, reject) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  args = setIndex(args, opts, resolve, reject);\n\n  if (instanceAvailability(pluginObj, methodName)) {\n    // eslint-disable-next-line prefer-spread\n    return pluginObj._objectInstance[methodName].apply(pluginObj._objectInstance, args);\n  }\n}\n/**\n * @param pluginRef\n */\n\nexport function getPlugin(pluginRef) {\n  if (typeof window !== 'undefined') {\n    return get(window, pluginRef);\n  }\n\n  return null;\n}\n/**\n * @param element\n * @param path\n */\n\nexport function get(element, path) {\n  var paths = path.split('.');\n  var obj = element;\n\n  for (var i = 0; i < paths.length; i++) {\n    if (!obj) {\n      return null;\n    }\n\n    obj = obj[paths[i]];\n  }\n\n  return obj;\n}\n/**\n * @param pluginName\n * @param plugin\n * @param method\n */\n\nexport function pluginWarn(pluginName, plugin, method) {\n  if (method) {\n    console.warn('Native: tried calling ' + pluginName + '.' + method + ', but the ' + pluginName + ' plugin is not installed.');\n  } else {\n    console.warn(\"Native: tried accessing the \" + pluginName + \" plugin but it's not installed.\");\n  }\n\n  if (plugin) {\n    console.warn(\"Install the \" + pluginName + \" plugin: 'ionic cordova plugin add \" + plugin + \"'\");\n  }\n}\n/**\n * @private\n * @param pluginName\n * @param method\n */\n\nexport function cordovaWarn(pluginName, method) {\n  if (typeof process === 'undefined') {\n    if (method) {\n      console.warn('Native: tried calling ' + pluginName + '.' + method + ', but Cordova is not available. Make sure to include cordova.js or run in a device/simulator');\n    } else {\n      console.warn('Native: tried accessing the ' + pluginName + ' plugin but Cordova is not available. Make sure to include cordova.js or run in a device/simulator');\n    }\n  }\n}\n/**\n * @param pluginObj\n * @param methodName\n * @param opts\n * @private\n */\n\nexport var wrap = function wrap(pluginObj, methodName, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (opts.sync) {\n      // Sync doesn't wrap the plugin with a promise or observable, it returns the result as-is\n      return callCordovaPlugin(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return wrapObservable(pluginObj, methodName, args, opts);\n    } else if (opts.eventObservable && opts.event) {\n      return wrapEventObservable(opts.event, opts.element);\n    } else if (opts.otherPromise) {\n      return wrapOtherPromise(pluginObj, methodName, args, opts);\n    } else {\n      return wrapPromise(pluginObj, methodName, args, opts);\n    }\n  };\n};\n/**\n * @param pluginObj\n * @param methodName\n * @param opts\n * @private\n */\n\nexport function wrapInstance(pluginObj, methodName, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (opts.sync) {\n      return callInstance(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return new Observable(function (observer) {\n        var pluginResult;\n\n        if (opts.destruct) {\n          pluginResult = callInstance(pluginObj, methodName, args, opts, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return observer.next(args);\n          }, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return observer.error(args);\n          });\n        } else {\n          pluginResult = callInstance(pluginObj, methodName, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n        }\n\n        if (pluginResult && pluginResult.error) {\n          observer.error(pluginResult.error);\n        }\n\n        return function () {\n          try {\n            if (opts.clearWithArgs) {\n              return callInstance(pluginObj, opts.clearFunction, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n            }\n\n            return callInstance(pluginObj, opts.clearFunction, []);\n          } catch (e) {\n            console.warn('Unable to clear the previous observable watch for', pluginObj.constructor.getPluginName(), methodName);\n            console.warn(e);\n          }\n        };\n      });\n    } else if (opts.otherPromise) {\n      return getPromise(function (resolve, reject) {\n        var result;\n\n        if (opts.destruct) {\n          result = callInstance(pluginObj, methodName, args, opts, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return resolve(args);\n          }, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return reject(args);\n          });\n        } else {\n          result = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n\n        if (result && result.then) {\n          result.then(resolve, reject);\n        } else {\n          reject();\n        }\n      });\n    } else {\n      var pluginResult_1, rej_1;\n      var p = getPromise(function (resolve, reject) {\n        if (opts.destruct) {\n          pluginResult_1 = callInstance(pluginObj, methodName, args, opts, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return resolve(args);\n          }, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return reject(args);\n          });\n        } else {\n          pluginResult_1 = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n\n        rej_1 = reject;\n      }); // Angular throws an error on unhandled rejection, but in this case we have already printed\n      // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n      // to error\n\n      if (pluginResult_1 && pluginResult_1.error) {\n        p.catch(function () {});\n        typeof rej_1 === 'function' && rej_1(pluginResult_1.error);\n      }\n\n      return p;\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["fromEvent","Observable","ERR_CORDOVA_NOT_AVAILABLE","error","ERR_PLUGIN_NOT_INSTALLED","getPromise","callback","tryNativePromise","Promise","resolve","reject","console","window","angular","doc","document","injector","element","querySelector","body","$q","get","warn","wrapPromise","pluginObj","methodName","args","opts","pluginResult","rej","p","destruct","callCordovaPlugin","catch","wrapOtherPromise","then","wrapObservable","observer","next","bind","complete","clearFunction","clearWithArgs","e","constructor","getPluginName","wrapEventObservable","event","checkAvailability","plugin","pluginName","pluginRef","pluginPackage","getPluginRef","getPluginInstallName","pluginInstance","getPlugin","cordova","cordovaWarn","pluginWarn","instanceAvailability","_objectInstance","setIndex","sync","callbackOrder","unshift","callbackStyle","push","err","result","successName","errorName","obj","successIndex","errorIndex","setSuccessIndex","length","splice","setErrorIndex","availabilityCheck","apply","callInstance","path","paths","split","i","method","process","wrap","observable","eventObservable","otherPromise","wrapInstance","pluginResult_1","rej_1"],"sources":["/data/data/com.termux/files/home/Ionic/ExploringApp/src/@awesome-cordova-plugins/core/decorators/common.ts"],"sourcesContent":["import { fromEvent, Observable } from 'rxjs';\n\nimport { CordovaOptions } from './interfaces';\n\ndeclare const window: any;\n\nexport const ERR_CORDOVA_NOT_AVAILABLE = { error: 'cordova_not_available' };\nexport const ERR_PLUGIN_NOT_INSTALLED = { error: 'plugin_not_installed' };\n\n/**\n * @param callback\n */\nexport function getPromise<T>(callback: (resolve: Function, reject?: Function) => any): Promise<T> {\n  const tryNativePromise = () => {\n    if (Promise) {\n      return new Promise<T>((resolve, reject) => {\n        callback(resolve, reject);\n      });\n    } else {\n      console.error(\n        'No Promise support or polyfill found. To enable Ionic Native support, please add the es6-promise polyfill before this script, or run with a library like Angular or on a recent browser.'\n      );\n    }\n  };\n\n  if (typeof window !== 'undefined' && window.angular) {\n    const doc = window.document;\n    const injector = window.angular.element(doc.querySelector('[ng-app]') || doc.body).injector();\n    if (injector) {\n      const $q = injector.get('$q');\n      return $q((resolve: Function, reject: Function) => {\n        callback(resolve, reject);\n      });\n    }\n    console.warn(\n      `Angular 1 was detected but $q couldn't be retrieved. This is usually when the app is not bootstrapped on the html or body tag. Falling back to native promises which won't trigger an automatic digest when promises resolve.`\n    );\n  }\n\n  return tryNativePromise();\n}\n\n/**\n * @param pluginObj\n * @param methodName\n * @param args\n * @param opts\n */\nexport function wrapPromise(pluginObj: any, methodName: string, args: any[], opts: CordovaOptions = {}) {\n  let pluginResult: any, rej: Function;\n  const p = getPromise((resolve: Function, reject: Function) => {\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        (...args: any[]) => resolve(args),\n        (...args: any[]) => reject(args)\n      );\n    } else {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject);\n    }\n    rej = reject;\n  });\n  // Angular throws an error on unhandled rejection, but in this case we have already printed\n  // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n  // to error\n  if (pluginResult && pluginResult.error) {\n    p.catch(() => {});\n    typeof rej === 'function' && rej(pluginResult.error);\n  }\n  return p;\n}\n\n/**\n * @param pluginObj\n * @param methodName\n * @param args\n * @param opts\n */\nfunction wrapOtherPromise(pluginObj: any, methodName: string, args: any[], opts: any = {}) {\n  return getPromise((resolve: Function, reject: Function) => {\n    const pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts);\n    if (pluginResult) {\n      if (pluginResult.error) {\n        reject(pluginResult.error);\n      } else if (pluginResult.then) {\n        pluginResult.then(resolve).catch(reject);\n      }\n    } else {\n      reject({ error: 'unexpected_error' });\n    }\n  });\n}\n\n/**\n * @param pluginObj\n * @param methodName\n * @param args\n * @param opts\n */\nfunction wrapObservable(pluginObj: any, methodName: string, args: any[], opts: any = {}) {\n  return new Observable((observer) => {\n    let pluginResult;\n\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        (...args: any[]) => observer.next(args),\n        (...args: any[]) => observer.error(args)\n      );\n    } else {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        observer.next.bind(observer),\n        observer.error.bind(observer)\n      );\n    }\n\n    if (pluginResult && pluginResult.error) {\n      observer.error(pluginResult.error);\n      observer.complete();\n    }\n    return () => {\n      try {\n        if (opts.clearFunction) {\n          if (opts.clearWithArgs) {\n            return callCordovaPlugin(\n              pluginObj,\n              opts.clearFunction,\n              args,\n              opts,\n              observer.next.bind(observer),\n              observer.error.bind(observer)\n            );\n          }\n          return callCordovaPlugin(pluginObj, opts.clearFunction, []);\n        }\n      } catch (e) {\n        console.warn(\n          'Unable to clear the previous observable watch for',\n          pluginObj.constructor.getPluginName(),\n          methodName\n        );\n        console.warn(e);\n      }\n    };\n  });\n}\n\n/**\n * Wrap the event with an observable\n *\n * @private\n * @param event event name\n * @param element The element to attach the event listener to\n * @returns {Observable}\n */\nfunction wrapEventObservable(event: string, element: any): Observable<any> {\n  element =\n    typeof window !== 'undefined' && element\n      ? get(window, element)\n      : element || (typeof window !== 'undefined' ? window : {});\n  return fromEvent(element, event);\n}\n\n/**\n * Checks if plugin/cordova is available\n *\n * @returns {boolean | { error: string } }\n * @private\n */\nexport function checkAvailability(\n  pluginRef: string,\n  methodName?: string,\n  pluginName?: string\n): boolean | { error: string };\nexport function checkAvailability(\n  pluginObj: any,\n  methodName?: string,\n  pluginName?: string\n): boolean | { error: string };\n/**\n * @param plugin\n * @param methodName\n * @param pluginName\n */\nexport function checkAvailability(plugin: any, methodName?: string, pluginName?: string): boolean | { error: string } {\n  let pluginRef, pluginPackage;\n\n  if (typeof plugin === 'string') {\n    pluginRef = plugin;\n  } else {\n    pluginRef = plugin.constructor.getPluginRef();\n    pluginName = plugin.constructor.getPluginName();\n    pluginPackage = plugin.constructor.getPluginInstallName();\n  }\n\n  const pluginInstance = getPlugin(pluginRef);\n\n  if (!pluginInstance || (!!methodName && typeof pluginInstance[methodName] === 'undefined')) {\n    if (typeof window === 'undefined' || !window.cordova) {\n      cordovaWarn(pluginName, methodName);\n      return ERR_CORDOVA_NOT_AVAILABLE;\n    }\n\n    pluginWarn(pluginName, pluginPackage, methodName);\n    return ERR_PLUGIN_NOT_INSTALLED;\n  }\n\n  return true;\n}\n\n/**\n * Checks if _objectInstance exists and has the method/property\n *\n * @param pluginObj\n * @param methodName\n * @private\n */\nexport function instanceAvailability(pluginObj: any, methodName?: string): boolean {\n  return pluginObj._objectInstance && (!methodName || typeof pluginObj._objectInstance[methodName] !== 'undefined');\n}\n\n/**\n * @param args\n * @param opts\n * @param resolve\n * @param reject\n */\nexport function setIndex(args: any[], opts: any = {}, resolve?: Function, reject?: Function): any {\n  // ignore resolve and reject in case sync\n  if (opts.sync) {\n    return args;\n  }\n\n  // If the plugin method expects myMethod(success, err, options)\n  if (opts.callbackOrder === 'reverse') {\n    // Get those arguments in the order [resolve, reject, ...restOfArgs]\n    args.unshift(reject);\n    args.unshift(resolve);\n  } else if (opts.callbackStyle === 'node') {\n    args.push((err: any, result: any) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    });\n  } else if (opts.callbackStyle === 'object' && opts.successName && opts.errorName) {\n    const obj: any = {};\n    obj[opts.successName] = resolve;\n    obj[opts.errorName] = reject;\n    args.push(obj);\n  } else if (typeof opts.successIndex !== 'undefined' || typeof opts.errorIndex !== 'undefined') {\n    const setSuccessIndex = () => {\n      // If we've specified a success/error index\n      if (opts.successIndex > args.length) {\n        args[opts.successIndex] = resolve;\n      } else {\n        args.splice(opts.successIndex, 0, resolve);\n      }\n    };\n\n    const setErrorIndex = () => {\n      // We don't want that the reject cb gets spliced into the position of an optional argument that has not been\n      // defined and thus causing non expected behavior.\n      if (opts.errorIndex > args.length) {\n        args[opts.errorIndex] = reject; // insert the reject fn at the correct specific index\n      } else {\n        args.splice(opts.errorIndex, 0, reject); // otherwise just splice it into the array\n      }\n    };\n\n    if (opts.successIndex > opts.errorIndex) {\n      setErrorIndex();\n      setSuccessIndex();\n    } else {\n      setSuccessIndex();\n      setErrorIndex();\n    }\n  } else {\n    // Otherwise, let's tack them on to the end of the argument list\n    // which is 90% of cases\n    args.push(resolve);\n    args.push(reject);\n  }\n  return args;\n}\n\n/**\n * @param pluginObj\n * @param methodName\n * @param args\n * @param opts\n * @param resolve\n * @param reject\n */\nexport function callCordovaPlugin(\n  pluginObj: any,\n  methodName: string,\n  args: any[],\n  opts: any = {},\n  resolve?: Function,\n  reject?: Function\n) {\n  // Try to figure out where the success/error callbacks need to be bound\n  // to our promise resolve/reject handlers.\n  args = setIndex(args, opts, resolve, reject);\n\n  const availabilityCheck = checkAvailability(pluginObj, methodName);\n\n  if (availabilityCheck === true) {\n    const pluginInstance = getPlugin(pluginObj.constructor.getPluginRef());\n    // eslint-disable-next-line prefer-spread\n    return pluginInstance[methodName].apply(pluginInstance, args);\n  } else {\n    return availabilityCheck;\n  }\n}\n\n/**\n * @param pluginObj\n * @param methodName\n * @param args\n * @param opts\n * @param resolve\n * @param reject\n */\nexport function callInstance(\n  pluginObj: any,\n  methodName: string,\n  args: any[],\n  opts: any = {},\n  resolve?: Function,\n  reject?: Function\n) {\n  args = setIndex(args, opts, resolve, reject);\n\n  if (instanceAvailability(pluginObj, methodName)) {\n    // eslint-disable-next-line prefer-spread\n    return pluginObj._objectInstance[methodName].apply(pluginObj._objectInstance, args);\n  }\n}\n\n/**\n * @param pluginRef\n */\nexport function getPlugin(pluginRef: string): any {\n  if (typeof window !== 'undefined') {\n    return get(window, pluginRef);\n  }\n  return null;\n}\n\n/**\n * @param element\n * @param path\n */\nexport function get(element: Element | Window, path: string) {\n  const paths: string[] = path.split('.');\n  let obj: any = element;\n  for (let i = 0; i < paths.length; i++) {\n    if (!obj) {\n      return null;\n    }\n    obj = obj[paths[i]];\n  }\n  return obj;\n}\n\n/**\n * @param pluginName\n * @param plugin\n * @param method\n */\nexport function pluginWarn(pluginName: string, plugin?: string, method?: string): void {\n  if (method) {\n    console.warn(\n      'Native: tried calling ' + pluginName + '.' + method + ', but the ' + pluginName + ' plugin is not installed.'\n    );\n  } else {\n    console.warn(`Native: tried accessing the ${pluginName} plugin but it's not installed.`);\n  }\n  if (plugin) {\n    console.warn(`Install the ${pluginName} plugin: 'ionic cordova plugin add ${plugin}'`);\n  }\n}\n\n/**\n * @private\n * @param pluginName\n * @param method\n */\nexport function cordovaWarn(pluginName: string, method?: string): void {\n  if (typeof process === 'undefined') {\n    if (method) {\n      console.warn(\n        'Native: tried calling ' +\n          pluginName +\n          '.' +\n          method +\n          ', but Cordova is not available. Make sure to include cordova.js or run in a device/simulator'\n      );\n    } else {\n      console.warn(\n        'Native: tried accessing the ' +\n          pluginName +\n          ' plugin but Cordova is not available. Make sure to include cordova.js or run in a device/simulator'\n      );\n    }\n  }\n}\n\n// Fixes a bug in TypeScript 2.9.2 where the ...args is being converted into args: {} and\n// causing compilation issues\nexport type WrapFn = (...args: any[]) => any;\n\n/**\n * @param pluginObj\n * @param methodName\n * @param opts\n * @private\n */\nexport const wrap = (pluginObj: any, methodName: string, opts: CordovaOptions = {}): WrapFn => {\n  return (...args: any[]) => {\n    if (opts.sync) {\n      // Sync doesn't wrap the plugin with a promise or observable, it returns the result as-is\n      return callCordovaPlugin(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return wrapObservable(pluginObj, methodName, args, opts);\n    } else if (opts.eventObservable && opts.event) {\n      return wrapEventObservable(opts.event, opts.element);\n    } else if (opts.otherPromise) {\n      return wrapOtherPromise(pluginObj, methodName, args, opts);\n    } else {\n      return wrapPromise(pluginObj, methodName, args, opts);\n    }\n  };\n};\n\n/**\n * @param pluginObj\n * @param methodName\n * @param opts\n * @private\n */\nexport function wrapInstance(pluginObj: any, methodName: string, opts: any = {}): Function {\n  return (...args: any[]) => {\n    if (opts.sync) {\n      return callInstance(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return new Observable((observer) => {\n        let pluginResult;\n\n        if (opts.destruct) {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            (...args: any[]) => observer.next(args),\n            (...args: any[]) => observer.error(args)\n          );\n        } else {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            observer.next.bind(observer),\n            observer.error.bind(observer)\n          );\n        }\n\n        if (pluginResult && pluginResult.error) {\n          observer.error(pluginResult.error);\n        }\n\n        return () => {\n          try {\n            if (opts.clearWithArgs) {\n              return callInstance(\n                pluginObj,\n                opts.clearFunction,\n                args,\n                opts,\n                observer.next.bind(observer),\n                observer.error.bind(observer)\n              );\n            }\n            return callInstance(pluginObj, opts.clearFunction, []);\n          } catch (e) {\n            console.warn(\n              'Unable to clear the previous observable watch for',\n              pluginObj.constructor.getPluginName(),\n              methodName\n            );\n            console.warn(e);\n          }\n        };\n      });\n    } else if (opts.otherPromise) {\n      return getPromise((resolve: Function, reject: Function) => {\n        let result;\n        if (opts.destruct) {\n          result = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            (...args: any[]) => resolve(args),\n            (...args: any[]) => reject(args)\n          );\n        } else {\n          result = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n        if (result && result.then) {\n          result.then(resolve, reject);\n        } else {\n          reject();\n        }\n      });\n    } else {\n      let pluginResult: any, rej: Function;\n      const p = getPromise((resolve: Function, reject: Function) => {\n        if (opts.destruct) {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            (...args: any[]) => resolve(args),\n            (...args: any[]) => reject(args)\n          );\n        } else {\n          pluginResult = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n        rej = reject;\n      });\n      // Angular throws an error on unhandled rejection, but in this case we have already printed\n      // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n      // to error\n      if (pluginResult && pluginResult.error) {\n        p.catch(() => {});\n        typeof rej === 'function' && rej(pluginResult.error);\n      }\n      return p;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}